/* Oliver Kullmann, 24.1.2008 (Swansea) */
/* Copyright 2008 Oliver Kullmann
This file is part of the OKlibrary. OKlibrary is free software; you can redistribute
it and/or modify it under the terms of the GNU General Public License as published by
the Free Software Foundation and included in this library; either version 3 of the
License, or any later version. */

/*!
  \file ComputerAlgebra/CombinatorialMatrices/Lisp/Basics.mac
  \brief Basic functionality for combinatorial matrices

Use by

oklib_load("Transitional/ComputerAlgebra/CombinatorialMatrices/Lisp/Basics.mac");

*/

/*!
\htmlonly
*/

oklib_include("Transitional/ComputerAlgebra/Hypergraphs/Lisp/SetSystems.mac")$
oklib_include("Transitional/ComputerAlgebra/DataStructures/Lisp/HashMaps.mac")$


/* ***********************
   * Basic constructions *
   ***********************
*/

/* Converts a square combinatorial matrix into a combinatorial matrix */
scom2com(M) := [M[1],M[1],M[2]]$

/* Converts a combinatorial matrix with equal row and column set into
   a square combinatorial matrix */
com2scom(M) := [M[1],M[3]]$

/* The empty combinatorial matrix */
emptycom : [{},{},lambda([i,j],false)]$
/* The empty square combinatorial matrix */
emptyscom : [{},lambda([i,j],false)]$
/* The zero combinatorial matrix for given index sets */
zerocom(I,J) := [I,J,lambda([i,j],0)]$
/* The zero square combinatorial matrix for a given index set */
zeroscom(I) := [I,lambda([i,j],0)]$
/* The constant combinatorial matrix for given index sets and value */
constantcom(I,J,a) := [I,J,buildq([a],lambda([i,j],a))]$
/* The constant square combinatorial matrix for given index set and value */
constantscom(I,a) := [I,buildq([a],lambda([i,j],a))]$

/* The identity matrix */
idscom(I) := [I, lambda([i,j],if i=j then 1 else 0)]$
/* The diagonal matrix with constant diagonal value */
cdiagscom(I,a) := [I,buildq([a],lambda([i,j],if i=j then a else 0))]$


/* *******************
   * Transformations *
   *******************
*/

/* Transforms a combinatorial matrix into a Maxima matrix: */
com2m(M) := block([rows : listify(M[1]), cols : listify(M[2]), f : M[3]],
  apply(matrix, create_list(create_list(f(i,j),j,cols),i,rows)))$
ocom2m(M) := block([rows : M[1], cols : M[2], f : M[3]],
  apply(matrix, create_list(create_list(f(i,j),j,cols),i,rows)))$

/* Transforms a square combinatorial matrix into a Maxima matrix: */
scom2m(M) := com2m(scom2com(M))$

/* Transforms a Maxima matrix into a combinatorial matrix
   (attention: this constitutes a reference to the original matrix). */
m2com(M) := block([m,n],
  [m,n] : matrix_size(M),
  [setn(m), setn(n),
    buildq([M], lambda([i,j], 'M[i,j]))])$
/* Transforms a square Maxima matrix into a square combinatorial matrix: */
sm2scom(M) := [setn(matrix_size(M)[1]), buildq([M], lambda([i,j], 'M[i,j]))]$

/* Transforms a square combinatorial matrix into a graph */
com2g(M) := [M[1], subset(powerset(M[1],2), lambda([S],
  block([L : listify(S)], return(is(M[2](L[1],L[2]) # 0)))))]$

/* Transforms a combinatorial matrix into a general hypergraph: */
com2ghyp(M) := [M[1], M[2], buildq([M], 
 lambda([j], subset(M[1], lambda([i], is(M[3](i,j) # 0)))))]$


/* *********************
   * Checking equality *
   *********************
*/

/* Equality test for combinatorial matrices: */
/* RENAME: com_equalp */
comequalp(A,B) := is(A[1] = B[1]) and is(A[2] = B[2]) and
 block([break : false],
  for a in A[1] unless break do for b in A[2] unless break do
    if A[3](a,b) # B[3](a,b) then break : true,
  return(not break))$
com_equalp(A,B) := comequalp(A,B)$
/* Equality test for square combinatorial matrices: */
/* RENAME: scom_equalp */
scomequalp(A,B) := is(A[1] = B[1]) and
 block([break : false],
  for a in A[1] unless break do for b in A[1] unless break do
    if A[2](a,b) # B[2](a,b) then break : true,
  return(not break))$
scom_equalp(A,B) := scomequalp(A,B)$


/* ********************
   * Basic operations *
   ********************
*/

/* The dimensions of a combinatorial matrix */
dim_com(M) := [length(M[1]), length(M[2])]$
/* The order of a square combinatorial matrix */
order_scom(M) := length(M[1])$

/* Transposition of a combinatorial matrix */
trans(M) := [M[2], M[1], buildq([M], lambda([i,j], M[3](j,i)))]$
/* Transposition of a square combinatorial matrix */
strans(M) := [M[1], buildq([M], lambda([i,j], M[2](j,i)))]$

/* The difference of two square combinatorial matrices
   Precondition: A[1] = B[1]. */
diff_scom(A,B) := [A[1], buildq([A,B],
  lambda([i,j], A[2](i,j) - B[2](i,j)))]$

/* Multiplying a square combinatorial matrix with a scalar */
scprod_scom(a,A) := [A[1], buildq([a,A], lambda([i,j], a * A[2](i,j)))]$

/* The product of two combinatorial matrices.
   Precondition: A[2] = B[1]. */
prod_com(A,B) := [A[1], B[2], buildq([A,B],
  lambda([i,j], sum(A[3](i,listify(A[2])[k]) * B[3](listify(B[1])[k],j), 
                    k,1,length(listify(A[2])))))]$

/* The minimum over all entries of a combinatorial matrix */
min_com(M) := lmin(map(lambda([p],apply(M[3],p)), cartesian_product(M[1],M[2])))$
/* The maximum over all entries of a combinatorial matrix */
max_com(M) := lmax(map(lambda([p],apply(M[3],p)), cartesian_product(M[1],M[2])))$

/* The sum over all entries of a combinatorial matrix */
sum_com(M) := block(
 [R : listify(M[1]), m, C : listify(M[2]), n],
  m : length(R), n : length(C),
  sum(sum(M[3](R[i],C[j]), i,1,m), j,1,n))$
/* The sum over all entries of a square combinatorial matrix */
sum_scom(M) := sum_com(scom2com(M))$

/* The entrywise absolute values of a combinatorial matrix */
abs_com(M) := [M[1], M[2], buildq([M],lambda([i,j], abs(M[3](i,j))))]$
/* The entrywise absolute values of a square combinatorial matrix */
abs_scom(M) := [M[1], buildq([M],lambda([i,j], abs(M[2](i,j))))]$

/* The distribution of row-sums, that is a list of pairs [possible
    row-sum, number of rows], sorted by ascending row-sum. */
rowsums_list_com(M) := list_distribution(
  create_list(lsum(M[3](i,j),j,listify(M[2])),i,listify(M[1])))$

/* The distribution of column-sums, that is a list of pairs [possible
    column-sum, number of rows], sorted by ascending row-sum. */
columnsums_list_com(M) := list_distribution(
  create_list(lsum(M[3](i,j),i,listify(M[1])),j,listify(M[2])))$


/*!
\endhtmlonly
*/
