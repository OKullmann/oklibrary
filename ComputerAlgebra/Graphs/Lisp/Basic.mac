/* Oliver Kullmann, 5.1.2008 (Swansea) */
/* Copyright 2008, 2009, 2010, 2011, 2018 Oliver Kullmann
This file is part of the OKlibrary. OKlibrary is free software; you can redistribute
it and/or modify it under the terms of the GNU General Public License as published by
the Free Software Foundation and included in this library; either version 3 of the
License, or any later version. */

/*!
  \file ComputerAlgebra/Graphs/Lisp/Basic.mac
  \brief Basic graph functionality

Use by

oklib_load("OKlib/ComputerAlgebra/Graphs/Lisp/Basic.mac");

*/

/*!
\htmlonly
*/

oklib_include("OKlib/ComputerAlgebra/Hypergraphs/Lisp/SetSystems.mac")$
oklib_include("OKlib/ComputerAlgebra/DataStructures/Lisp/HashMaps.mac")$
oklib_include("OKlib/ComputerAlgebra/DataStructures/Lisp/Lists.mac")$
oklib_include("OKlib/ComputerAlgebra/Graphs/Lisp/Statistics.mac")$

oklib_plain_include(graphs)$


/* ***********************
   * Fundamental notions *
   ***********************
*/

/* A "graph" is a 2-element list, consisting of the set of
   vertices, and a set of 2-element vertex sets.
   A "graph with loops" also allows 1-element vertex sets.
*/

/* A "digraph" is a 2-element list, consisting of the set of vertices,
   and a set of 2-element vertex lists with different elements.
   A "digrap with loops" also allows the elements to be identical.
*/

/* A "multigraph" is a triple [V,E,f] such that [V,E] is a graph,
   and such that f is a function which assigns to every edge its
   cardinality, a natural number (>0).
   A "multigraph with loops" allows loops.
   CHANGE: this should change to a pair [V,f], such that f({a,b})
   is the multiplicity >= 0 of edge {a,b}.
*/

/* A "multi-digraph" is similarly a triple [V,E,f] such that [V,E] is
   is digraph; and a "multi-digraph with loops" allows loops.
   CHANGE: similarly, this should change to a pair [V,f], where
   f([a,b]) is the multiplicity >= 0 of arc [a,b].
*/

/* A "general graph" is a triple [V,E,f], where f maps each element of
   E to a 1- or 2-element subset of V.
   For a "general digraph" f yields lists of length 1 or 2.
*/

/* The ordered versions of all the above notions use lists instead of
   sets, but without repetition.
*/

/* See "Providing basic test cases" in
   ComputerAlgebra/Graphs/Lisp/tests/Basic.mac
   for basic examples.
*/


/* ************************************
   * Checking the defining properties *
   ************************************
*/

g_p(G) := listp(G) and is(length(G)=2) and setp(G[1]) and setp(G[2]) and 
  every_s(lambda([e], setp(e) and is(length(e) = 2) and subsetp(e,G[1])), G[2])$
gl_p(G) := listp(G) and is(length(G)=2) and setp(G[1]) and setp(G[2]) and 
  every_s(lambda([e], setp(e) and elementp(length(e),{1,2}) and subsetp(e,G[1])),G[2])$
dg_p(G) := listp(G) and is(length(G)=2) and setp(G[1]) and setp(G[2]) and 
  every_s(lambda([e], listp(e) and is(length(e)=2 and e[1]#e[2]) and subsetp(setify(e),G[1])), G[2])$
dgl_p(G) := listp(G) and is(length(G)=2) and setp(G[1]) and setp(G[2]) and 
  every_s(lambda([e], listp(e) and is(length(e)=2) and subsetp(setify(e),G[1])), G[2])$
mug_p(G) := listp(G) and is(length(G)=3) and g_p([G[1],G[2]]) and
  every_s(lambda([e], block([n : G[3](e)], integerp(n) and n > 0)), G[2])$
mugl_p(G) := listp(G) and is(length(G)=3) and gl_p([G[1],G[2]]) and
  every_s(lambda([e], block([n : G[3](e)], integerp(n) and n > 0)), G[2])$
mudg_p(G) := listp(G) and is(length(G)=3) and dg_p([G[1],G[2]]) and
  every_s(lambda([e], block([n : G[3](e)], integerp(n) and n > 0)), G[2])$
mudgl_p(G) := listp(G) and is(length(G)=3) and dgl_p([G[1],G[2]]) and
  every_s(lambda([e], block([n : G[3](e)], integerp(n) and n > 0)), G[2])$
gg_p(G) := listp(G) and is(length(G)=3) and setp(G[1]) and setp(G[2]) and
  every_s(lambda([e], block([s : G[3](e)],
    setp(s) and elementp(length(s),{1,2}) and subsetp(s,G[1]))), G[2])$
gdg_p(G) := listp(G) and is(length(G)=3) and setp(G[1]) and setp(G[2]) and
  every_s(lambda([e], block([l : G[3](e)],
    listp(l) and is(length(l)=2) and subsetp(setify(l),G[1]))), G[2])$

og_p(G) := listp(G) and is(length(G)=2) and listnorep_p(G[1]) and listnorep_p(G[2]) and
  every_s(lambda([e], setp(e) and is(length(e) = 2) and subsetp(e,setify(G[1]))), G[2])$
ogl_p(G) := listp(G) and is(length(G)=2) and listnorep_p(G[1]) and listnorep_p(G[2]) and 
  every_s(lambda([e], setp(e) and elementp(length(e),{1,2}) and subsetp(e,setify(G[1]))), G[2])$
odg_p(G) := listp(G) and is(length(G)=2) and listnorep_p(G[1]) and listnorep_p(G[2]) and 
  every_s(lambda([e], listp(e) and is(length(e)=2 and e[1]#e[2]) and subsetp(setify(e),setify(G[1]))), G[2])$
odgl_p(G) := listp(G) and is(length(G)=2) and listnorep_p(G[1]) and listnorep_p(G[2]) and 
  every_s(lambda([e], listp(e) and is(length(e)=2) and subsetp(setify(e),setify(G[1]))), G[2])$
omug_p(G) := listp(G) and is(length(G)=3) and og_p([G[1],G[2]]) and
  every_s(lambda([e], block([n : G[3](e)], integerp(n) and n > 0)), G[2])$
omugl_p(G) := listp(G) and is(length(G)=3) and ogl_p([G[1],G[2]]) and
  every_s(lambda([e], block([n : G[3](e)], integerp(n) and n > 0)), G[2])$
omudg_p(G) := listp(G) and is(length(G)=3) and odg_p([G[1],G[2]]) and
  every_s(lambda([e], block([n : G[3](e)], integerp(n) and n > 0)), G[2])$
omudgl_p(G) := listp(G) and is(length(G)=3) and odgl_p([G[1],G[2]]) and
  every_s(lambda([e], block([n : G[3](e)], integerp(n) and n > 0)), G[2])$
ogg_p(G) := listp(G) and is(length(G)=3) and listnorep_p(G[1]) and listnorep_p(G[2]) and
  every_s(lambda([e], block([s : G[3](e)],
    setp(s) and elementp(length(s),{1,2}) and subsetp(s,setify(G[1])))), G[2])$
ogdg_p(G) := listp(G) and is(length(G)=3) and listnorep_p(G[1]) and listnorep_p(G[2]) and
  every_s(lambda([e], block([l : G[3](e)],
    listp(l) and is(length(l)=2) and subsetp(setify(l),setify(G[1])))), G[2])$


/* *********************
   * Checking equality *
   *********************
*/

/* Equality checking for (directed) graphs (with loops) happens via normal
   "syntactical" equality testing, however for multigraphs and general
   graphs this would demand that the terms for the edge functions are equal,
   and so here we define special equality tests.
*/
/* G1, G2, can be of arbitrary but identical graph-type: */
gr_equalp(G1,G2) := if length(G1)=2 then is(G1 = G2) else
 is(G1[1] = G2[1] and G1[2] = G2[2]) and
  every_s(lambda([e],is(G1[3](e)=G2[3](e))), G1[2])$


/* **************
   * Promotions *
   **************
*/

/* Promotions g -> gl and mug -> mugl happen implicitly. */

/* Works for g2mug, gl2mugl, og2omug, ogl2omugl, dg2mudg, dgl2mudgl, odg2omudg,
   odgl2omudgl: */
generic_g2mug(G) := [G[1], G[2], lambda([e],1)]$
/* Works for g2gg, gl2gg, og2ogg, ogl2ogg, dg2gdg, dgl2gdg, odg2ogdg,
   odgl2ogdg: */
generic_g2gg(G) := [G[1], G[2], identity]$
/* Works for mug2gg, mugl2gg, mudg2gdg, mudgl2gdg: */
generic_mug2gg(G) := block([L : listify(G[2])],
  [G[1],
   setify(create_list([e,i], e,L, i,1,G[3](e))),
   first
  ])$
/* Works for omug2ogg, omugl2ogg, omudg2ogdg, omudgl2ogdg: */
generic_omug2ogg(G) := 
  [G[1], 
   create_list([e,i], e,G[2], i,1,G[3](e)),
   first
  ]$
/* Works for g2og, gl2ogl, dg2odg, dgl2odgl: */
generic_g2og(G) := [listify(G[1]), listify(G[2])]$
/* Works for mug2omug, mugl2omugl, mudg2omudg, mudgl2omudgl, gg2ogg, gdg2ogdg: */
generic_gg2ogg(G) := [listify(G[1]), listify(G[2]), G[3]]$

g2mug(G) := generic_g2mug(G)$
gl2mugl(G) := generic_g2mug(G)$
g2gg(G) := generic_g2gg(G)$
gl2gg(G) := generic_g2gg(G)$
mug2gg(G) := generic_mug2gg(G)$
mugl2gg(G) := generic_mug2gg(G)$

ogl2omugl(G) := generic_g2mug(G)$
og2ogg(G) := generic_g2gg(G)$
ogl2ogg(G) := generic_g2gg(G)$
omugl2ogg(G) := generic_omug2ogg(G)$

g2og(G) := generic_g2og(G)$
gl2ogl(G) := generic_g2og(G)$
mug2omug(G) := generic_gg2ogg(G)$
mugl2omugl(G) := generic_gg2ogg(G)$
gg2ogg(G) := generic_gg2ogg(G)$

dg2mudg(G) := generic_g2mug(G)$
dgl2mudgl(G) := generic_g2mug(G)$
dg2gdg(G) := generic_g2gg(G)$
dgl2gdg(G) := generic_g2gg(G)$
mudg2gdg(G) := generic_mug2gg(G)$
mudgl2gdg(G) := generic_mug2gg(G)$

odgl2omudgl(G) := generic_g2mug(G)$
odg2ogdg(G) := generic_g2gg(G)$
odgl2ogdg(G) := generic_g2gg(G)$
omudgl2ogdg(G) := generic_omug2ogg(G)$

dg2odg(G) := generic_g2og(G)$
dgl2odgl(G) := generic_g2og(G)$
mudg2omudg(G) := generic_gg2ogg(G)$
mudgl2omudgl(G) := generic_gg2ogg(G)$
gdg2ogdg(G) := generic_gg2ogg(G)$


/* *************
   * Downcasts *
   *************
*/

generic_gg2mugl(G) := [
 G[1], 
 map(G[3],G[2]),
 buildq([G],lambda([e],length(subset(G[2],lambda([x],is(G[3](x)=e))))))
]$
generic_ogg2omugl(G) := [
 G[1], 
 stable_unique(map(G[3],G[2])),
 buildq([G],lambda([e],length(sublist(G[2],lambda([x],is(G[3](x)=e))))))
]$

mug2g(G) := [G[1],G[2]]$
mugl2gl(G) := [G[1],G[2]]$
gg2gl(G) := [G[1], map(G[3],G[2])]$
gg2mugl(G) := generic_gg2mugl(G)$

omug2og(G) := [G[1],G[2]]$
omugl2ogl(G) := [G[1],G[2]]$
ogg2ogl(G) := [G[1], stable_unique(map(G[3],G[2]))]$
ogg2omugl(G) := generic_ogg2omugl(G)$

og2g(G) := [setify(G[1]), setify(G[2])]$
ogl2gl(G) := [setify(G[1]), setify(G[2])]$
omug2mug(G) := [setify(G[1]), setify(G[2]), G[3]]$
omugl2mugl(G) := [setify(G[1]), setify(G[2]), G[3]]$
ogg2gg(G) := [setify(G[1]), setify(G[2]), G[3]]$

mudg2dg(G) := [first(G),second(G)]$
mudgl2dgl(G) := [G[1],G[2]]$
gdg2dgl(G) := [G[1], map(G[3],G[2])]$
gdg2mudgl(G) := generic_gg2mugl(G)$

omudg2odg(G) := [G[1],G[2]]$
omudgl2odgl(G) := [G[1],G[2]]$
ogdg2odgl(G) := [G[1], stable_unique(map(G[3],G[2]))]$
ogdg2omudgl(G) := generic_ogg2omugl(G)$

odg2dg(G) := [setify(G[1]), setify(G[2])]$
odgl2dgl(G) := [setify(G[1]), setify(G[2])]$
omudg2mudg(G) := [setify(G[1]), setify(G[2]), G[3]]$
omudgl2mudgl(G) := [setify(G[1]), setify(G[2]), G[3]]$
ogdg2gdg(G) := [setify(G[1]), setify(G[2]), G[3]]$


/* ***************
   * Conversions *
   ***************
*/

/* Removal of loops: */
gl2g(G) := [G[1], subset(G[2],lambda([e],is(length(e)=2)))]$
gg2g(G) := gl2g(gg2gl(G))$
ogl2og(G) := [G[1], sublist(G[2],lambda([e],is(length(e)=2)))]$
ogg2og(G) := ogl2og(ogg2ogl(G))$
mugl2mug(G) := [G[1], subset(G[2],lambda([e],is(length(e)=2))), G[3]]$
omugl2omug(G) := [G[1], sublist(G[2],lambda([e],is(length(e)=2))), G[3]]$
dgl2dg(G) := [G[1], subset(G[2],lambda([e],is(first(e)#second(e))))]$
odgl2odg(G) := [G[1], sublist(G[2],lambda([e],is(first(e)#second(e))))]$

/* Underlying graphs of directed graphs: */
dg2g(G) := [G[1], map(setify,G[2])]$
odg2og(G) := [G[1], stable_unique(map(setify,G[2]))]$
dgl2gl(G) := [G[1], map(setify,G[2])]$
odgl2ogl(G) := [G[1], stable_unique(map(setify,G[2]))]$
gdg2gg(G) := [G[1], G[2], buildq([G],lambda([e],setify(G[3](e))))]$
ogdg2ogg(G) := [G[1], G[2], buildq([G],lambda([e],setify(G[3](e))))]$
mudg2mug(G) := 
 endcons(buildq([E:G[2],ef:G[3]], 
     lambda([e], block([e1:listify(e), e2], e2 : reverse(e1),
       if elementp(e1,E) then ef(e1) + if elementp(e2,E) then ef(e2) else 0
       else ef(e2)))), 
     dg2g(mudg2dg(G)))$

/* Representing graphs by directed graphs: */
g2dg(G) := [G[1], setify(lappend(
  map(lambda([e], block([d : listify(e)], [d,reverse(d)])),
      listify(G[2]))))]$
gl2dgl(G) := [G[1], setify(lappend(
  map(lambda([e], block([d : listify(e)], 
        if length(d)=1 then [append(d,d)] else [d,reverse(d)])),
      listify(G[2]))))]$
mug2mudg(G) := block([DG : g2dg(mug2g(G))], 
 endcons(buildq([ef:G[3]], lambda([e], ef(setify(e)))), DG))$


/* **************************
   * Basic graph operations *
   **************************
*/

/* Auxiliary function, expanding an undirected edge into a directed
   edge, using the given Maxima-order: */
expand_edge(ue) := block([de : listify(ue)],
  if length(de) = 2 then de else append(de,de))$

/* The set of neighbours of vertex v in graph G. */
/* RENAME to "neighbours_g". */
neighbours(v,G) := disjoin(v, lunion(
 subset(G[2], lambda([e],elementp(v,e)))))$
neighbours_g(v,G) := neighbours(v,G)$
neighbours_og(v,G) := disjoin(v, lunion(
 sublist(G[2], lambda([e],elementp(v,e)))))$
neighbours_gl(v,G) := lunion( 
 map(lambda([e], if e={v} then e else disjoin(v,e)),
     sublist(listify(G[2]), lambda([e],elementp(v,e)))))$
neighbours_gg(v,G) := neighbours_gl(v,gg2gl(G))$

outneighbours_dg(v,G) := outneighbours_dgl(v,G)$
outneighbours_dgl(v,G) :=
 setify(map(second,sublist(listify(G[2]), lambda([e], is(e[1]=v)))))$
inneighbours_dg(v,G) := inneighbours_dgl(v,G)$
inneighbours_dgl(v,G) :=
 setify(map(first,sublist(listify(G[2]), lambda([e], is(e[2]=v)))))$


/* Removes vertex set V from graph G (with loops). */
/* RENAME: "remove_vertices_gl". */
remove_vertices_graph(V,G) := [setdifference(G[1],V),
 subset(G[2], lambda([e], disjointp(e,V)))]$
remove_vertices_gl(V,G) := remove_vertices_graph(V,G)$


/* *****************************
   * Basic graph constructions *
   *****************************
*/

/* The induced subgraph of a graph G, given by an edge-set , using precisely
   the edges in E, and their endpoints as vertices; it is assumed that
   E is a subset of the edge-set of the graph; of for multi-graphs is their
   a real dependency on G, namely the multiplicites are taken over: */

edge_induced_subgraph_g(E,G) := [lunion(E),E]$
edge_induced_subgraph_gl(E,G) := edge_induced_subgraph_g(E,G)$
edge_induced_subgraph_mug(E,G) := [lunion(E),E,G[3]]$
edge_induced_subgraph_mugl(E,G) := edge_induced_subgraph_mug(E,G)$
edge_induced_subgraph_gg(E,G) := [lunion(map(G[3],E)),E,G[3]]$
edge_induced_subgraph_dg(E,G) := [lunion(map(setify,E)),E]$
edge_induced_subgraph_dgl(E,G) := edge_induced_subgraph_dg(E,G)$
edge_induced_subgraph_mudg(E,G) := [lunion(map(setify,E)),E,G[3]]$
edge_induced_subgraph_mudgl(E,G) := edge_induced_subgraph_mudg(E,G)$
edge_induced_subgraph_gdg(E,G) := [lunion(map(setify,(map(G[3],E)))),E,G[3]]$

/* The ordinary vertex-induced subgraphs: */
induced_subgraph_g(V,G) := [V,subset(G[2], lambda([e], subsetp(e,V)))]$
induced_subgraph_gl(V,G) := induced_subgraph_g(V,G)$
induced_subgraph_dg(V,G) := [V, subset(G[2], lambda([e], subsetp(setify(e),V)))]$
induced_subgraph_dgl(V,G) := induced_subgraph_dg(V,G) $

/* The complement-graph of a graph: */
/* RENAME to "complement_g". */
comp_graph(G) := [G[1], setdifference(powerset(G[1],2),G[2])]$
complement_g(G) := comp_graph(G)$

/* The transposed of a directed graph: */
transposed_dg(G) := [G[1], map(reverse,G[2])]$
transposed_dgl(G) := [G[1], map(reverse,G[2])]$
transposed_odg(G) := [G[1], map(reverse,G[2])]$
transposed_odgl(G) := [G[1], map(reverse,G[2])]$


/* **********
   * Tests  *
   **********
*/

/* Tests whether a general or multi-graph has parallel edges: */
parallel_edges_gg_p(G) := is(length(map(G[3],G[2])) < length(G[2]))$
parallel_edges_mug_p(G) := some_s(lambda([e],is(G[3](e)>1)),G[2])$
parallel_edges_mugl_p(G) := some_s(lambda([e],is(G[3](e)>1)),G[2])$
parallel_edges_ogg_p(G) := is(length(setify(map(G[3],G[2]))) < length(G[2]))$
parallel_edges_omug_p(G) := some_s(lambda([e],is(G[3](e)>1)),G[2])$
parallel_edges_omugl_p(G) := some_s(lambda([e],is(G[3](e)>1)),G[2])$


/* Tests whether a graph with loops is irreflexive (that is, doesn't actually
   have loops): */
irreflexive_gl_p(G) := every_s(lambda([e],is(length(e)=2)), G[2])$
irreflexive_mugl_p(G) := every_s(lambda([e],is(length(e)=2)),G[2])$
irreflexive_gg_p(G) := every_s(lambda([e],is(length(G[3](e))=2)),G[2])$
irreflexive_ogl_p(G) := every_s(lambda([e],is(length(e)=2)),G[2])$
irreflexive_omugl_p(G) := every_s(lambda([e],is(length(e)=2)),G[2])$
irreflexive_ogg_p(G) := every_s(lambda([e],is(length(G[3](e))=2)),G[2])$


/* An "oriented graph" is, following the abuse of language in [Jensen,
   Gutin; Digraphs], a directed graph without antiparallel edges: */
orientedgraph_dg_p(G) := not is(length(map(setify,G[2])) < length(G[2]))$
orientedgraph_dgl_p(G) := not is(length(map(setify,G[2])) < length(G[2]))$
orientedgraph_odg_p(G) := not is(length(setify(map(setify,G[2]))) < length(G[2]))$
orientedgraph_odgl_p(G) := not is(length(setify(map(setify,G[2]))) < length(G[2]))$


/* Tests whether a graph is complete: */
complete_g_p(G) := is(binomial(length(G[1]),2) = length(G[2]))$
complete_gl_p(G) := complete_g_p(gl2g(G))$
complete_og_p(G) := is(binomial(length(G[1]),2) = length(G[2]))$
complete_ogl_p(G) := complete_og_p(ogl2og(G))$
complete_mug_p(G) := complete_g_p(mug2g(G))$
complete_mugl_p(G) := complete_gl_p(mugl2gl(G))$
complete_omug_p(G) := complete_og_p(omug2og(G))$
complete_omugl_p(G) := complete_ogl_p(omugl2ogl(G))$
complete_gg_p(G) := complete_gl_p(gg2gl(G))$
complete_ogg_p(G) := complete_ogl_p(ogg2ogl(G))$

/* Checks for dominating vertices in graphs with and without loops: */
dominating_vertex_g_p(v,G) := 
  is(length(neighbours_g(v,G)) = length(G[1])-1)$
dominating_vertex_gl_p(v,G) := 
  is(length(neighbours_gl(v,G)) = length(G[1]))$

has_dominating_vertex_g(G) :=
  is(max_vertex_degree_v_og(g2og(G))[1] = length(G[1])-1)$
/* Remark: has_dominating_vertex_g(G) =
  some_s(lambda([v],dominating_vertex_g_p(v,G)), G[1]).
*/
has_dominating_vertex_gl(G) :=
  is(max_vertex_degree1_v_ogl(gl2ogl(G))[1] = length(G[1]))$
/* Remark: has_dominating_vertex_gl(G) =
  some_s(lambda([v],dominating_vertex_gl_p(v,G)), G[1]).
*/


/* Tests whether a graph is connected: */
connected_g_p(G) := is_connected(g2mg(G))$
connected_og_p(G) := is_connected(og2mg(G))$
connected_mug_p(G) :=  connected_g_p(mug2g(G))$
connected_omug_p(G) :=  connected_og_p(omug2og(G))$
connected_gg_p(G) :=  connected_gl_p(gg2gl(G))$
connected_ogg_p(G) :=  connected_ogl_p(ogg2ogl(G))$
connected_gl_p(G) := is_connected(g2mg(gl2g(G)))$
connected_ogl_p(G) := is_connected(og2mg(ogl2og(G)))$
connected_mugl_p(G) :=  connected_gl_p(mugl2gl(G))$
connected_omugl_p(G) :=  connected_ogl_p(omugl2ogl(G))$

/* Tests whether a digraph is strongly connected: */
sconnected_dg_p(G) := emptyp(G[1]) or is_sconnected(dg2mdg(G))$
sconnected_odg_p(G) := emptyp(G[1]) or is_sconnected(odg2mdg(G))$
sconnected_mudg_p(G) := sconnected_dg_p(mudg2dg(G))$
sconnected_omudg_p(G) := sconnected_odg_p(omudg2odg(G))$
sconnected_gdg_p(G) := sconnected_dgl_p(gdg2dgl(G))$
sconnected_ogdg_p(G) := sconnected_odgl_p(ogdg2odgl(G))$
sconnected_dgl_p(G) := sconnected_dg_p(dgl2dg(G))$
sconnected_odgl_p(G) := sconnected_odg_p(odgl2odg(G))$
sconnected_mudgl_p(G) := sconnected_dgl_p(mudgl2dgl(G))$
sconnected_omudgl_p(G) := sconnected_odgl_p(omudgl2odgl(G))$

/* Tests whether a digraph is minimally strongly connected: */
minsconnected_dg_p(G) := if not sconnected_dg_p(G) then false else
 block([res : true],
   for e in second(G) do
     if sconnected_dg_p([first(G), disjoin(e,second(G))]) then
       (res : false, return(done)),
   res
 )$


/* Tests whether a graph is a tree: */
tree_g_p(G) := is_tree(g2mg(G))$
tree_og_p(G) := is_tree(og2mg(G))$
tree_mug_p(G) :=  not parallel_edges_mug_p(G) and tree_g_p(mug2g(G))$
tree_omug_p(G) :=  not parallel_edges_omug_p(G) and tree_og_p(omug2og(G))$
tree_gg_p(G) :=  not parallel_edges_gg_p(G) and tree_gl_p(gg2gl(G))$
tree_ogg_p(G) :=  not parallel_edges_ogg_p(G) and tree_ogl_p(ogg2ogl(G))$
tree_gl_p(G) := irreflexive_gl_p(G) and tree_g_p(G)$
tree_ogl_p(G) := irreflexive_ogl_p(G) and tree_og_p(G)$
tree_mugl_p(G) :=  irreflexive_mugl_p(G) and tree_mug_p(G)$
tree_omugl_p(G) :=  irreflexive_omugl_p(G) and tree_omug_p(G)$


/* Tests whether a graph is regular: */
regular_g_p(k,G) := block([h : hm2osm(vertex_degrees_g(G))],
  every_s(lambda([p],is(second(p) = k)),h))$
/* Counting loops once in a general graph: */
regular1_gg_p(k,G) := block([h : hm2osm(vertex_degrees1_gg(G))],
  every_s(lambda([p],is(second(p) = k)),h))$
/* Counting loops twice in a general graph: */
regular2_gg_p(k,G) := block([h : hm2osm(vertex_degrees2_gg(G))],
  every_s(lambda([p],is(second(p) = k)),h))$


/* Tests whether a graph is a cycle graph: */
cycle_gg_p(G) := not emptyp(G[1]) and connected_gg_p(G) and regular2_gg_p(2,G)$

/* Tests whether a graph is bipartite: */
bipartite_g_p(G) := is_bipartite(g2mg(G))$

/* Tests whether a graph is complete bipartite: */
completebipartite_g_p(G) := if emptyp(G[1]) then true
 else connected_g_p(G) and block([B : bipartition(g2mg(G))],
   not emptyp(B) and is(length(B[1]) * length(B[2]) = length(G[2])))$
/* Remark: A graph is complete bipartite iff adding any edge either destroys
   the graph property of destroys bipartiteness. */
completebipartite_gl_p(G) := irreflexive_gl_p(G) and completebipartite_g_p(G)$
completebipartite_gg_p(G) := completebipartite_gl_p(gg2gl(G))$


/* **************
   * Symmetries *
   **************
*/

/* Using the dreadnaut-tool, as part of nauty
     http://users.cecs.anu.edu.au/~bdm/nauty/
   to obtain information on the automorphism group:
*/
/* Printing a digraph G, vertices starting with 0, without gaps, in the
   dreadnaut input-format:
*/
print_dreadnaut_std0dg(G) := block([n : lmax(first(G))+1],
 print("+d"),
 print(sconcat("n=", n, " g")),
 for v : 0 thru n-1 do
   print(sconcat(dimacs_c_string(outneighbours_dg(v,G)), if v#n-1 then ";" else ".")),
 print("x")
)$
output_dreadnaut_std0dg(G,f) := with_stdout(f, print_dreadnaut_std0dg(G))$
/* For example
     output_dreadnaut_std0dg([{0,1,2},{[0,1],[1,2],[2,0]}], "Test.graph");
$ cat Test.graph | ./dreadnaut
(0 1 2)
level 1:  1 orbit; 0 fixed; index 3
1 orbit; grpsize=3; 1 gen; 3 nodes; maxlev=2
cpu time = 0.00 seconds
*/


/* ********************************
   * Connections to Maxima-graphs *
   ********************************
*/

/* Graphs to Maxima-graphs (vertex names yield vertex labels).
   The vertices in the Maxima-graph are numbered starting with 1.
   Edges in the Maxima-graph are ordered in an implementation-defined way,
   while the vertex-order is preserved.
*/
og2mg(G) := block(
 [V : G[1], E : G[2], h],
  h : osm2hm(l2osm_inv(V)),
  create_graph(l2osm(V),
    create_list([ev_hm(h,listify(e)[1]), ev_hm(h,listify(e)[2])], e, E)
  )
)$
g2mg(G) := og2mg(gl2ogl(G))$
/* Without the vertex-labels: */
og2mg_nl(G) := block(
 [V : G[1], E : G[2], h, n : length(G[1])],
 h : osm2hm(l2osm_inv(V)),
 create_graph(create_list(i,i,1,n), 
   create_list([ev_hm(h,listify(e)[1]), ev_hm(h,listify(e)[2])], e, E)
 )
)$
g2mg_nl(G) := og2mg_nl(gl2ogl(G))$

/* Maxima-graphs to ordered graphs, moving 0-based indices to 1-based
   (ignoring the vertex labels). */
mg2og(g) := block([V : vertices(g), E : edges(g)],
  if elementp_l(0,V) then (V:V+1, E:E+1),
  return([V,map(setify,E)]))$
/* Maxima-graphs to graphs (ignoring the vertex labels): */
mg2g(g) := block([G : mg2og(g)], [setify(G[1]), setify(G[2])])$


/* Digraphs to Maxima-digraphs (vertex names yield vertex labels).
   The vertices in the Maxima-digraph are numbered starting with 1. */
dg2mdg(G) := block(
 [V : listify(G[1]), E : listify(G[2]), h : sm2hm({}), n : length(G[1])],
 for i : 1 thru n do set_hm(h, V[i], i),
 return(
   create_graph(
     create_list([i,V[i]],i,1,n), 
     create_list([ev_hm(h,e[1]), ev_hm(h,e[2])], e, E),
     true
 ))
)$

odg2mdg(G) := block(
 [V : G[1], E : G[2], h : sm2hm({}), n : length(G[1])],
 for i : 1 thru n do set_hm(h, V[i], i),
 return(
   create_graph(
     create_list([i,V[i]],i,1,n), 
     create_list([ev_hm(h,e[1]), ev_hm(h,e[2])], e, E),
     true
 ))
)$


/*!
\endhtmlonly
*/
