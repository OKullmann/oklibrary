/* Oliver Kullmann, 29.11.2007 (Swansea) */
/* Copyright 2007, 2008 Oliver Kullmann
This file is part of the OKlibrary. OKlibrary is free software; you can redistribute
it and/or modify it under the terms of the GNU General Public License as published by
the Free Software Foundation and included in this library; either version 3 of the
License, or any later version. */

/*!
  \file ComputerAlgebra/Satisfiability/Lisp/ClauseSets/BasicOperations.mac
  \brief Functions for basic operations with clause-sets

Use by

oklib_load("Transitional/ComputerAlgebra/Satisfiability/Lisp/ClauseSets/BasicOperations.mac");

*/

/*!
\htmlonly
*/

oklib_include("Transitional/ComputerAlgebra/Hypergraphs/Lisp/SetSystems.mac")$

/* **************************
   * Variables and literals *
   **************************
*/

/*
 A "boolean variable" might be any expression x, such that "- x" is defined
 and yields a different object, and such that abs(x) = x.
*/

/* 
 A "boolean literal" might be a boolean variable "v" or a negated boolean
 variable "-v".
*/

/* the underlying variable of a literal */
var_l(x) := abs(x)$

/* The sign of a literal in {-1,+1}. */
sign_l(x) := block([s : sign(x)], if s = pos then 1 else -1)$

/* the literals for a set of variables */
literals_v(V) := block([L : listify(V)],
  setify(append(L,-L)))$

/* ***********
   * Clauses *
   ***********
*/

/* complementation of a set of literals */
comp_sl(L) := map(lambda([l], -l), L)$

/*
 A "boolean clause" is a set C of boolean literals such that
 C and comp_sl(C) have empty intersection.
*/

/* Tests whether two literal sets contain a clashing literal. */
clashp(A,B) := not emptyp(intersection(A,comp_sl(B)))$

/* The set of variables in a clause */
var_c(C) := map(var_l, C)$

/* The positive literals in a clause */
pospart_c(C) := subset(C, lambda([x], is(x>0)))$
/* The negative literals in a clause */
negpart_c(C) := subset(C, lambda([x], is(x<0)))$


/* ***************
   * Clause-sets *
   ***************
*/

/*
 A "boolean clause-set" is a set of boolean clauses.
*/

/*
 A "formal boolean clause-set" is a pair [V, F], where V is a set of
 variables, while F is a clause-set using only variables from V
 (that is, with var_cs(F) <= V).
*/

/* the variables in a clause-set */
var_cs(F) := if emptyp(F) then {} else xreduce(union, map(var_c, F))$
/* the variables in a formal clause-set */
var_cs_f(FF) := FF[1]$

/* the clause-set of a formal clause-set */
clauses_f(FF) := FF[2]$

/* clause-sets to formal clause-sets */
cs_to_fcs(F) := [var_cs(F), F]$


/* ************************************
   * Representing boolean clause-sets *
   ************************************
*/

/* The clause-variable matrix of a formal clause-set (as a combinatorial
   matrix) */
cvcom(FF) := [FF[2], FF[1], lambda([C,v],
 block([i : intersection(C, {v,-v})],
  if emptyp(i) then return(0)
  elseif i = {v} then return(+1)
  else return(-1)))]$



/* ************
   * Renaming *
   ************
*/

load(graphs)$ /* needed for the hash-table */

/* rename literal x via hash table h */
rename_literal(x,h) := if x > 0 then get_hash(x,h) else -get_hash(-x,h)$

/* rename clause C via hash table h */
rename_clause(C,h) := map(lambda([x],rename_literal(x,h)), C)$

/* Translating variable names of a formal clause-set into natural numbers; 
   outputs a pair consisting of the translated formal clause-set and
   the list of old variable names (positions corresponding to new
   variable-numbers) */
standardise_fcs(FF) := block([h : hash_table(), V : listify(FF[1])],
 for i : 1 thru length(V) do set_hash(V[i], h, i),
 return([[setn(length(V)), map(lambda([C],rename_clause(C,h)), FF[2])],V]))$


/* ************
   * Measures *
   ************
*/

/* number of variables of a formal clause-set */
nvar_f(FF) := length(var_cs_f(FF))$
/* number of variables of a clause-set */
nvar_cs(F) := length(var_cs(F))$


/* number of clauses of a formal clause-set */
ncl_f(FF) := length(clauses_f(FF))$
/* number of clauses of a clause-set */
ncl_cs(F) := length(F)$

/* number of literal occurrences in a clause-set */
nlitocc(F) := block([s : 0],
 for C in F do s : s + length(C), return(s))$
 
/* the list of pairs
   [occurring clause-lengths, number of clauses of this length],
   sorted by ascending clause-length.
*/
ncl_list_f(FF) := block([counts : make_array(fixnum, length(FF[1])+1), res : []],
 for C in FF[2] do block([l : length(C)],
  counts[l] : counts[l] + 1),
 for i : 0 thru length(FF[1]) do
  if counts[i] # 0 then res : endcons([i, counts[i]], res),
 return(res))$

/* maximal clause-length of a clause-set */
max_rank_cs(F) := block([m : -1],
  for C in F do if length(C) > m then m : length(C),
  return(m))$
/* minimal clause-length of a clause-set */
min_rank_cs(F) := block([m : inf],
  for C in F do if length(C) < m then m : length(C),
  return(m))$
/* Tests whether a clause-set F is uniform */
uniformcsp(F) := is(max_rank_cs(F) <= min_rank_cs(F))$

/* Gathers main statistics for a clause-set */
statistics_cs(F) := 
  [nvar_cs(F),ncl_cs(F),nlitocc(F),max_rank_cs(F),min_rank_cs(F)]$
/* Gathers main statistics for a formal clause-set */
statistics_fcs(FF) := 
  [nvar_f(FF),ncl_f(FF),nlitocc(FF[2]),max_rank_cs(FF[2]),min_rank_cs(FF[2])]$


/* The degree of a literal in a clause-set */
literal_degree_cs(F,l) := length(subset(F,lambda([C],elementp(l,C))))$

load(graphs)$
/* the literal-degrees of a clause-set, as hash-map */
literal_degrees_cs(F) := block([h : hash_table()],
 for C in F do
  for x in C do block([val : get_hash(x,h)],
   if val=false then set_hash(x,h,1)
   else set_hash(x,h,val+1)),
 return(h))$
/* minimal literal-degree of a clause-set */
min_literal_degree_cs(F) := 
  lmin(map(lambda([A],part(A,2)),hash_table_data(literal_degrees_cs(F))))$
/* maximal literal-degree of a clause-set */
max_literal_degree_cs(F) := 
  lmax(map(lambda([A],part(A,2)),hash_table_data(literal_degrees_cs(F))))$
/* also returns a literal of maximal degree (if there is a literal) */
max_literal_degree_l_cs(F) := if F = {} or F = {{}} then [minf,0] else block(
  [D : map(lambda([A],[part(A,1),part(A,2)]),hash_table_data(literal_degrees_cs(F))),  
   optl : 0, maxd : minf],
  for m in D do block([d : m[2]],
    if d > maxd then (maxd : d, optl : m[1])),
  return([maxd, optl]))$
/* Ordering relation for literal,degree pairs */
literal_degree_ordering_des(ld1, ld2) := is(second(ld2) < second(ld1))$
/* Returns the pairs of literal and literal degree of a clause-set F in 
   descending order of the number of literals
   OK: why is this needed? How is the order specified??
   Use better variable names!
   The loop should be eliminated! And just map the hash-table.
   The order used deviates from the normal order imposed on literals. */
ordered_literal_degrees_cs(F) := block([ldl : [], ldh : literal_degrees_cs(F)],
   for v in var_cs(F) do block(
       block([ld : get_hash(v,ldh)],
           if not (ld = false) then
               ldl : cons([v,ld],ldl)),
       block([ld : get_hash(-v,ldh)],
           if not (ld = false) then
               ldl : cons([-v,ld],ldl))),
   return(sort(ldl,literal_degree_ordering_des)))$
/* OK; ???? what is this doing ? What is "tb" ? */
max_literal_degree_tb(FF,l,d,n) := block([max_ld1, max_ld2, max_l1, max_l2],
      [max_l1, max_ld1] : max_literal_degree_tb_l_cs(apply_pa_f({l}, FF),d,n),
      [max_l2, max_ld2] : max_literal_degree_tb_l_cs(apply_pa_f({-l}, FF),d,n),
      [if max_ld1 > max_ld2 then max_l1 else max_l2, max_ld1 + max_ld2])$
/* Returns the pair of literal and literal degree for the literal
   with the maximum degree in the given clause set, where look-aheads are made
   when a tie occurs for the maximum degree, looking up to d levels deeper 
   and considering up to n tied literals. */
/* OK: "look-ahead" ??? */
max_literal_degree_tb_l_cs(FF,d,n) := block(
  [old : ordered_literal_degrees_cs(FF[2])],
  if emptyp(old) then [0,0]
  else if d < 1 then old[1]
  else
    xreduce(lambda([a,b], if second(a) > second(b) then a else b), 
      map(lambda([c], max_literal_degree_tb(FF, first(c),d-1,n)), 
        block([ml : sublist(rest(old),lambda([a],is(second(a)=second(first(old)))))],
          take_elements(min(n,length(ml)),ml))),
    first(old)))$
/* tests whether a clause-set is literal-regular (all literals have the same
   degree) */
literalregularcsp(F) := is(min_literal_degree_cs(F) >= max_literal_degree_cs(F))$
/* the average literal degree of a formal clause-set */
mean_literal_degree_fcs(FF) := nlitocc(FF[2]) / (2 * nvar_f(FF))$
/* literal frequencies in various forms: */
min_literal_frequency_cs(F) := min_literal_degree_cs(F) / ncl_cs(F)$
max_literal_frequency_cs(F) := max_literal_degree_cs(F) / ncl_cs(F)$
mean_literal_frequency_cs(FF) := mean_literal_degree_cs(FF) / ncl_f(FF)$

/* the variable-degrees of a clause-set, as hash-map */
variable_degrees_cs(F) := block([h : hash_table()],
 for C in F do
  for v in var_c(C) do block([val : get_hash(v,h)],
   if val=false then set_hash(v,h,1)
   else set_hash(v,h,val+1)),
 return(h))$
/* minimal variable-degree of a clause-set */
min_variable_degree_cs(F) := 
  lmin(map(lambda([A],part(A,2)),hash_table_data(variable_degrees_cs(F))))$
/* maximal variable-degree of a clause-set */
max_variable_degree_cs(F) := 
  lmax(map(lambda([A],part(A,2)),hash_table_data(variable_degrees_cs(F))))$
/* also returns a variable of maximal degree (if there is a variable) */
max_variable_degree_v_cs(F) := if F = {} or F = {{}} then [minf,0] else block(
  [D : map(lambda([A],[part(A,1),part(A,2)]),hash_table_data(variable_degrees_cs(F))),  
   optv : 0, maxd : minf],
  for m in D do block([d : m[2]],
    if d > maxd then (maxd : d, optv : m[1])),
  return([maxd, optv]))$
/* tests whether a clause-set is variable-regular (all variables have the same
   degree) */
variableregularcsp(F) := is(min_variable_degree_cs(F) >= max_variable_degree_cs(F))$
/* the average variable-degree of a formal clause-set */
mean_variable_degree_cs(FF) := 2 * mean_literal_degree_fcs(FF)$
/* literal frequencies in various forms: */
min_variable_frequency_cs(F) := min_variable_degree_cs(F) / ncl_cs(F)$
max_variable_frequency_cs(F) := max_variable_degree_cs(F) / ncl_cs(F)$
mean_variable_frequency_cs(FF) := mean_variable_degree_fcs(FF) / ncl_f(FF)$


/* ***********************************
   * Selecting parts of a clause-set *
   ***********************************
*/

/* all clauses of length k of a clause-set */
scls_k(F,k) := subset(F, lambda([C], is(length(C) = k)))$


/* ***********************
   * Partial assignments *
   ***********************
*/

/*
 A "partial boolean assignment" is a boolean clause, interpreted
 as setting its elements to true.
*/

/* The variables in a partial assignment. */
var_pa(phi) := var_c(phi)$

/* Restricting a partial assignment phi to a set V of variables. */
restr_pa(phi,V) := subset(phi, lambda([x], elementp(var_l(x),V)))$

/* apply a partial assignment to a boolean clause-set */
apply_pa(phi,F) := setdifference2(remove_non_disjoint(F,phi), comp_sl(phi))$
/* apply a partial assignment to a formal boolean clause-set */
apply_pa_f(phi,FF) := [setdifference(var_cs_f(FF), var_c(phi)),
  apply_pa(phi, clauses_f(FF))]$

/* The set of satisfied clauses for a partial assignment w.r.t. a clause-set */
sat_pa(phi,F) := subset(F, lambda([C], is(apply_pa(phi,{C}) = {})))$

/* Test for a satisfying assignment w.r.t. a clause-set */
satisfyingpap(phi,F) := is(sat_pa(phi,F) = F)$

/* the set of satisfied, falsified, untouched and critical clauses for
   a partial assignment w.r.t. a clause-set */
analyse_pa(phi,F) := block([V : var_c(phi), s : {}, f : {}, u : {}, c : {}],
 for C in F do block([r : apply_pa(phi,{C})],
  if r = {} then s : adjoin(C,s)
  elseif r = {{}} then f : adjoin(C,f)
  elseif disjointp(var_c(C), V) then u : adjoin(C,u) 
  else c : adjoin(C,c)),
 return([s,f,u,c]))$


/* *****************************************
   * Printing clause-sets in Dimacs-format *
   *****************************************
*/

/* output a literal */
dimacs_l_string(x) := sconcat(x," ")$

/* output a clause */
dimacs_c_string(C) := xreduce(sconcat, map(dimacs_l_string, C))$

/* print a string without line-breaks */
print_nlb(s) := block([old_linel : linel],
  linel : slength(s) + 1,
  print(s),
  linel : old_linel)$

/* print a formal clause-set in Dimacs format */
print_cs_f(comment,FF) := (
  print_nlb(sconcat("c ", comment)),
  print_nlb(sconcat("p cnf ", nvar_f(FF), " ", length(clauses_f(FF)))),
  for C in clauses_f(FF) do print_nlb(sconcat(dimacs_c_string(C), "0"))
)$

/* output formal clause-set FF to file n */
output_cs_f(comment,FF,n) := with_stdout(n, print_cs_f(comment,FF))$

/* print a formal clause-set in Dimacs format, together with a map
   which explains the variable meaning */
print_cs_f_v(comment,FF,varlist) := (
  print_nlb(sconcat("c ", comment)),
  for i from 1 thru length(varlist) do print_nlb(sconcat("c ", i, " : ", varlist[i])),
  print_nlb(sconcat("p cnf ", nvar_f(FF), " ", length(clauses_f(FF)))),
  for C in clauses_f(FF) do print_nlb(sconcat(dimacs_c_string(C), "0"))
)$

/* output formal clause-set FF to file n, using a variable-list */
output_cs_f_v(comment,FF,n,varlist) := 
  with_stdout(n, print_cs_f_v(comment,FF,varlist))$


/*!
\endhtmlonly
*/
