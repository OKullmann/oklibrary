/* Oliver Kullmann, 14.12.2007 (Swansea) */
/* Copyright 2007, 2008, 2009, 2010, 2011, 2012 Oliver Kullmann
This file is part of the OKlibrary. OKlibrary is free software; you can redistribute
it and/or modify it under the terms of the GNU General Public License as published by
the Free Software Foundation and included in this library; either version 3 of the
License, or any later version. */

/*!
  \file ComputerAlgebra/Satisfiability/Lisp/Resolution/Basics.mac
  \brief Functions for resolution operations on clause-sets

Use by

oklib_load("OKlib/ComputerAlgebra/Satisfiability/Lisp/Resolution/Basics.mac");

*/

/*!
\htmlonly
*/

oklib_include("OKlib/ComputerAlgebra/Satisfiability/Lisp/ClauseSets/BasicOperations.mac")$
oklib_include("OKlib/ComputerAlgebra/Hypergraphs/Lisp/SetSystems.mac")$
oklib_include("OKlib/ComputerAlgebra/DataStructures/Lisp/Lists.mac")$
oklib_include("OKlib/ComputerAlgebra/DataStructures/Lisp/HashMaps.mac")$


/* ***************************
   * Single resolution steps *
   ***************************
*/

/* Checks */

/* Checks whether two clauses are resolvable: */
resolvable(C,D) := singletonp(intersection(C, comp_sl(D)))$

/* Checks whether two clauses are resolvable and that the resolvent subsumes 
   the two parents: */
two_subsumption_resolvable(C,D) := resolvable(C,D) and is(length(symmdifference(C,D)) = 2)$


/* Basic resolution operations */

/* The resolution literal of two resolvable clauses: */
resolution_literal(C,D) := single_element(intersection(C, comp_sl(D)))$

/* The resolvent of two resolvable clauses: */
resolvent(C,D) := block([x : resolution_literal(C,D)], union(disjoin(x, C), disjoin(-x, D)))$


/* Resolution operations as partial operations, returning either [R]  or []. */

/* If clauses C,D are resolvable with resolution literal x, then return [x],
   else return []: */
resolvable_p(C,D) :=  block([clashs : intersection(C, comp_sl(D))],
 if length(clashs) = 1 then [single_element(clashs)] else [])$

/* If C,D are 2-subsumption-resolvable, return [R], else []: */
two_subsumption_resolvent_p(C,D) := block([x : resolvable_p(C,D)],
 if not emptyp(x) then 
  block([x : x[1], R],
   R : disjoin(x,C), if R = disjoin(-x,D) then return([R]) else return([]))
 else return([]))$
/* two_subsumption_resolvent_p(C,D) =
 if two_subsumption_resolvable(C,D) then [resolvent(C,D)] else [] */


/* The variations for sets of parent clauses */

/* Checks whether a set of clauses is resolvable: */
resolvable_s(S) := block([L : listify(S)], resolvable(L[1], L[2]))$

/* The resolvent of a resolvable set of clauses: */
resolvent_s(S) := block([L : listify(S)], resolvent(L[1], L[2]))$


/* The variation for a given resolution literal */

/* Checks whether two clauses are resolvable on a given resolution literal: */
resolvable_l(C,D,x) := is(intersection(C, comp_sl(D)) = {x})$

/* Checks whether a set of clauses is resolvable on a given resolution literal: */
resolvable_s_l(S,x) := block([L : listify(S)], resolvable_l(L[1], L[2], x) or
 resolvable_l(L[1], L[2], -x))$

/* The resolvent of two resolvable clauses on a given resolution literal: */
resolvent_l(C,D,x) := union(disjoin(x, C), disjoin(-x, D))$

/* The resolvent of a resolvable set of clauses on a given resolution literal:
*/
resolvent_s_l(S,x) := block([L : listify(S)], setdifference(union(L[1], L[2]), {x,-x}))$


/* *************************
   * Adding all resolvents *
   *************************
*/

/* The resolvable 2-sets of a clause-set: */
resolvable_cs(F) := block([LF : l2array(listify(F)), l : length(F), R : []],
 for i : 1 thru l-1 do block([C : LF[i]],
  for j : i+1 thru l do
   if resolvable(C, LF[j]) then R : cons({C,LF[j]}, R)),
 return(setify(R)))$
/* resolvable_cs(F) = subset(powerset(F,2), resolvable_s) */

/* The 2-subsumption-resolvable 2-sets of a clause-set: */
two_subsumption_resolvable_cs(F) := block(
 [LF : l2array(listify(F)), l : length(F), R : []],
 for i : 1 thru l-1 do block([C : LF[i]],
  for j : i+1 thru l do
   if two_subsumption_resolvable(C, LF[j]) then R : cons({C,LF[j]}, R)),
 return(setify(R)))$

/* All resolvents of a clause-set: */
resolvents_cs(F) := map(resolvent_s, resolvable_cs(F))$

/* All 2-subsumption-resolvents of a clause-set: */
two_subsumption_resolvents_cs(F) := map(resolvent_s, two_subsumption_resolvable_cs(F))$

/* Returns a pair [res, R], where res is the set of 2-subsumption-resolvents
   of F, while R is the set of remaining clauses of F, i.e., clauses not 
   subsumed by their 2-subsumption-resolvents: */
two_subsumption_resolvents_rem_cs(F) := block(
 [L : l2array(listify(F)), l : length(F), subsumed, result : {}],
  subsumed : okl_make_array(fixnum, l),
  for i : 1 thru l - 1 do block([C : L[i], used : false],
    for j : i+1 thru l do block([R : two_subsumption_resolvent_p(C,L[j])],
      if not emptyp(R) then (
        result : adjoin(R[1], result),
        used : true, subsumed[j] : 1)),
    if used then subsumed[i] : 1),
  return([result,setify(sublist_indicator(array2l(L),subsumed))]))$

/* Adds all resolvents to a clause-set: */
add_resolvents_cs(F) := union(F, resolvents_cs(F))$



/* ***********************
   * Iterated resolution *
   ***********************
*/

monitorcheck_resolution_closure_init(name) := if oklib_monitor then (
  print(sconcat("M[",name,"]:"), history))$
monitorcheck_resolution_closure_loop(name) := if oklib_monitor then (
  print(last(history)))$


/* The (full) resolution closure of a clause-set (returning a pair, where
   the second element is the list of clause-counts for the stages): */
resolution_closure_cs(F) := block([nF : add_resolvents_cs(F), history : [length(F)]],
  history : append(history, [length(nF)]),
  monitorcheck_resolution_closure_init("resolution_closure_cs"),
  while length(nF) > length(F) do (
    F : nF, nF : add_resolvents_cs(F),
    history : append(history, [length(nF)]),
    monitorcheck_resolution_closure_loop("resolution_closure_cs")
  ),
  return([nF, history]))$


/* Adds all resolvents to a clause-set and then applies 
   subsumption-elimination: */
min_add_resolvents_cs(F) := min_elements(add_resolvents_cs(F))$

/* The prime-implicates of a clause-set F (as CNF), and the list of 
   clause-counts for the successive extensions of F (until a fixed point is 
   reached): */
min_resolution_closure_cs(F) := block(
 [nF : min_add_resolvents_cs(F), history : [length(F)]],
  history : append(history, [length(nF)]),
  monitorcheck_resolution_closure_init("min_resolution_closure_cs"),
  while nF # F do (
    F : nF, nF : min_add_resolvents_cs(F),
    history : append(history, [length(nF)]),
    monitorcheck_resolution_closure_loop("min_resolution_closure_cs")
  ),
  return([nF, history]))$
/* A basic equality is
   min_resolution_closure_cs(F)[1] = min_elements(resolution_closure_cs(F)[1]).
   Another basic equality (yielding an alternative computation) is
   min_resolution_closure_cs(F)[1] = min_2resolution_closure_cs(expand_fcs(cs2fcs(F))[2]).
*/


/* *****************
   * DP resolution *
   *****************
*/

/* The resolvable 2-sets of a clause-set on a given resolution literal: */
resolvable_cs_l(F,x) := subset(powerset(F,2), lambda([Cs], resolvable_s_l(Cs,x)))$

/* All resolvents of a clause-set on a given resolution literal: */
resolvents_cs_l(F,x) := map(lambda([S], resolvent_s_l(S,x)), resolvable_cs_l(F,x))$

/* The DP-operator in one step for clause-set F and resolution literal v: */
/* RENAME: dp_operator_cs */
dp_operator(F,v) := block(
 [Fv : subset(F, lambda([C], not disjointp(C, {v,-v})))],
  union(setdifference(F, Fv), resolvents_cs_l(Fv,v)))$
dp_operator_cs(F,v) := dp_operator(F,v)$
dp_operator_fcs(FF,v) := [disjoin(v,FF[1]), dp_operator_cs(FF[2],v)]$

/* DP combined with subsumption elimination: */
min_dp_operator(F,v) := min_elements(dp_operator(F,v))$

/* Returns a list of pairs [s,c], where s is the size of DP-procedure-run
   (the sum of sizes of the clause-sets) and c is the count, where the list
   is sorted by ascending s: */
distribution_min_dp(FF) := block(
 [P : permutations(FF[1]), l : length(FF[2]), hash, counts : {}],
  for p in P do block([F : FF[2], s : l],
    for v in p do (
      F : min_dp_operator(F,v),
      s : s + length(F)
    ),
    if elementp(s, counts) then hash[s] : hash[s] + 1 else (
      counts : adjoin(s, counts), hash[s] : 1)
  ),
  return(create_list([s, hash[s]], s, listify(counts))))$


/* *******************
   * Blocked clauses *
   *******************
*/

/* A clause C is blocked for a clause-set F if there exists a literal l in C,
   called the blocking literal, such that no resolution in F on l with C
   is possible.

   A blocked extension of a clause-set F is a clause-set F' such that
   the (confluent) result of removing blocked clauses from union(F',F)
   and F yields the same result. This is equivalent to checking whether
   the result of removing blocked clauses from union(F',F) is a subset of F.
*/

/* Checking whether l is a blocking literal in a clause C for clause-set F: */
blocking_literal_p(F,C,l) :=
  elementp(C,F) and elementp(l,C) and
    every_s(lambda([D], not(elementp(-l,D)) or not(resolvable(C,D))), F)$

/* Checking whether the clause C is blocked for F: */
blocked_cs_p(F,C) := some_s(lambda([l], blocking_literal_p(F,C,l)), C)$

/* Eliminating blocked clauses from F: */
elim_blocked_cs(F) := block([tF : F, had_blocked : true],
  while had_blocked do block([F_blocked],
    F_blocked : subset(tF, lambda([C], blocked_cs_p(tF,C))),
    if emptyp(F_blocked) then had_blocked : false
    else tF : setdifference(tF, F_blocked)),
  return(tF))$

/* Checking whether eF is a blocked extension of F: */
blocked_extension_cs_p(eF,F) :=
  subsetp(elim_blocked_cs(union(eF,F)), F)$

/*!
\endhtmlonly
*/
