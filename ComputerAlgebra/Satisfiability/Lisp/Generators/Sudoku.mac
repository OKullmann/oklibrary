/* Oliver Kullmann, 5.2.2008 (Swansea) */
/* Copyright 2008, 2009, 2011, 2013 Oliver Kullmann
This file is part of the OKlibrary. OKlibrary is free software; you can redistribute
it and/or modify it under the terms of the GNU General Public License as published by
the Free Software Foundation and included in this library; either version 3 of the
License, or any later version. */

/*!
  \file ComputerAlgebra/Satisfiability/Lisp/Generators/Sudoku.mac
  \brief Generations of Sudoku-problems (also generalised, and also as generalised SAT-problems)

Use by

oklib_load("OKlib/ComputerAlgebra/Satisfiability/Lisp/Generators/Sudoku.mac");

  See CombinatorialMatrices/Lisp/LatinSquares/BasicNotions.mac
  for notions and tests regarding latin squares.

*/

/*!
\htmlonly
*/

oklib_include("OKlib/ComputerAlgebra/Satisfiability/Lisp/ClauseSets/BasicOperations.mac")$
oklib_include("OKlib/ComputerAlgebra/NumberTheory/Lisp/Auxiliary.mac")$
oklib_include("OKlib/ComputerAlgebra/DataStructures/Lisp/Lists.mac")$


/* *************
   * Variables *
   *************
*/

/* Variables for the direct encoding are "sdk(i,j,k)", meaning that 
   field (i,j) carries number k: */
kill(sdk)$
declare(sdk, noun)$
declare(sdk, posfun)$
sdk_var(i,j,k) := nounify(sdk)(i,j,k)$
/* Here we have 1 <= i, j <= N, where N = p^2 is the dimension of the whole
   matrix, while p is the "box dimension" (p=3 for the standard Sudoku
   problems, while N=9).
*/

/* The list of variables for Sudoku formulas in direct encoding
   of box-dimension p: */
var_sdk(p) := block([N : p^2],
 create_list(sdk_var(i,j,k), i,1,N, j,1,N, k,1,N))$

/* Standardise all Sudoku-variables in term T w.r.t. direct encoding
   (for box-dimension p): */
standardise_sdk(T,p) := block([N : p^2],
 ev(T, sdk(i,j,k) := (i-1)*N^2 + (j-1)*N + (k-1) +1, sdk))$
/* For standardised variable n, compute the corresponding sdk-variable.
   Prerequisite: p >= 1, 1 <= n <= (p^2)^3.
*/
invstandardise_sdk(n,p) := block([N : p^2, R],
 R : int2polyadic_padd(n-1, N, 3),
 apply(sdk_var,1+R))$


/* *************************
   * The basic translation *
   *************************
*/

/* Realise constraints for different numbers in each row: */
sdk_different_rows_cl(p) := block([N : p^2],
 create_list({-sdk_var(i,j1,k), -sdk_var(i,j2,k)}, 
                    i,1,N, k,1,N, j1,1,N-1, j2,j1+1,N))$

/* Realise constraints for different numbers in each column: */
sdk_different_columns_cl(p) := block([N : p^2],
 create_list({- sdk_var(i1,j,k), - sdk_var(i2,j,k)}, 
                    j,1,N, k,1,N, i1,1,N-1, i2,i1+1,N))$


/* Given coordinates 1 <= i,j <= p of one of the N boxes, compute the list of 
   coordinates of the N fields in the box (from top-left to bottom-right):
*/
sdk_positions_box(i,j,p) := block(
 [row_offset : p * (i-1), column_offset : p * (j-1)],
 create_list([row_offset + r, column_offset + c], r,1,p, c,1,p))$

/* Realise constraints for different numbers in each box: */
sdk_different_boxes_cl(p) := block([N : p^2, L : []],
 for i : 1 thru p do
  for j : 1 thru p do block([P : sdk_positions_box(i,j,p)],
   for k : 1 thru N do
    for p1 : 1 thru N-1 do
     for p2 : p1+1 thru N do
      L : cons({- sdk_var(P[p1][1],P[p1][2],k), - sdk_var(P[p2][1],P[p2][2],k)}, L)),
 L)$

/* Realise constraints that every field carries a number: */
sdk_all_fields_cl(p) := block([N : p^2],
 create_list(setify(create_list(sdk_var(i,j,k), k,1,N)), i,1,N, j,1,N))$


/* The Sudoku problem in weak form (direct encoding) as formal clause-list: */
weak_sdk_fcl(p) := [var_sdk(p), 
 append(sdk_different_rows_cl(p), 
        sdk_different_columns_cl(p),
        sdk_different_boxes_cl(p),
        sdk_all_fields_cl(p))]$
weak_sdk_stdfcl(p) := standardise_sdk(weak_sdk_fcl(p),p)$
weak_sdk_fcs(p) := fcl2fcs(weak_sdk_fcl(p))$
weak_sdk_stdfcs(p) := fcl2fcs(weak_sdk_stdfcl(p))$


/* Output an "empty" Sudoku problem to a file, using the weak translation
   and direct encoding: */
output_weak_sdk(p,filename) := block([FF : weak_sdk_stdfcl(p)],
  output_fcl_v(
    sconcat(
"The Sudoku problem (weak form) with box-dimension ", p, ".
c Generated by the OKlibrary at Maxima-level."),
    FF,
    filename,
    []))$
output_weak_sdk_stdname(p) := 
  output_weak_sdk(p,sconcat("Weak_Sudoku_Box_dim_",p,".cnf"))$


/* **************************
   * Additional constraints *
   **************************
*/

/* Realise constraints that every row contains all numbers: */
sdk_all_rows_cl(p) := block([N : p^2],
 create_list(setify(create_list(sdk_var(i,j,k),j,1,N)), i,1,N, k,1,N))$

/* Realise constraints that every column contains all numbers: */
sdk_all_columns_cl(p) := block([N : p^2],
 create_list(setify(create_list(sdk_var(i,j,k),i,1,N)), j,1,N, k,1,N))$

/* Realise constraints that every box contains all numbers: */
sdk_all_boxes_cl(p) := block([N : p^2],
 create_list(setify(create_list(sdk_var(p[1],p[2],k),p,sdk_positions_box(i,j,p))),
  i,1,p, j,1,p, k,1,N))$

/* Realise constraints that every field carries at most one number: */
sdk_different_fields_cl(p) := block([N : p^2],
  create_list({-sdk_var(i,j,k1), -sdk_var(i,j,k2)}, 
         i,1,N, j,1,N, k1,1,N-1, k2,k1+1,N))$


/* The Sudoku problem in dual weak form (direct encoding) as formal 
   clause-list: */
dual_weak_sdk_fcl(p) := [var_sdk(p), 
 append(sdk_all_rows_cl(p),
        sdk_all_columns_cl(p),
        sdk_all_boxes_cl(p),
        sdk_different_fields_cl(p))]$
dual_weak_sdk_stdfcl(p) := standardise_sdk(dual_weak_sdk_fcl(p),p)$
dual_weak_sdk_fcs(p) := fcl2fcs(dual_weak_sdk_fcl(p))$
dual_weak_sdk_stdfcs(p) := fcl2fcs(dual_weak_sdk_stdfcl(p))$


/* Output an "empty" Sudoku problem to a file, using the dual weak translation
   and direct encoding: */
output_dual_weak_sdk(p,filename) := block([FF : dual_weak_sdk_stdfcl(p)],
  output_fcl_v(
    sconcat(
"The Sudoku problem (dual weak form) with box-dimension ", p, ".
c Generated by the OKlibrary at Maxima-level."),
    FF,
    filename,
    []))$
output_dual_weak_sdk_stdname(p) := 
  output_dual_weak_sdk(p,sconcat("Dual_Weak_Sudoku_Box_dim_",p,".cnf"))$


/* The strong Sudoku problem (direct encoding) as formal clause-list: */
strong_sdk_fcl(p) := [var_sdk(p), 
 append(weak_sdk_fcl(p)[2], dual_weak_sdk_fcl(p)[2])]$
strong_sdk_stdfcl(p) := standardise_sdk(strong_sdk_fcl(p),p)$
strong_sdk_fcs(p) := fcl2fcs(strong_sdk_fcl(p))$
strong_sdk_stdfcs(p) := fcl2fcs(strong_sdk_stdfcl(p))$
strong_sdk_stdofcs(p) := fcs2fcl(strong_sdk_stdfcs(p))$


/* Output an "empty" Sudoku problem to a file, using the strong translation 
   and direct encoding: */
output_strong_sdk(p,filename) := block([FF : strong_sdk_stdfcl(p)],
  output_fcl_v(
    sconcat(
"The Sudoku problem (strong form) with box-dimension ", p, ".
c Generated by the OKlibrary at Maxima-level."),
    FF,
    filename,
    []))$
output_strong_sdk_stdname(p) := 
  output_strong_sdk(p,sconcat("Strong_Sudoku_Box_dim_",p,".cnf"))$


/* ***************
   * Mixed forms *
   ***************
*/

/* The weak form, plus either the long or the binary clauses from the
   dual weak form:
*/

weakpl_sdk_fcl(p) := [var_sdk(p), 
 append(sdk_different_rows_cl(p), 
        sdk_different_columns_cl(p),
        sdk_different_boxes_cl(p),
        sdk_all_fields_cl(p),
        sdk_all_rows_cl(p),
        sdk_all_columns_cl(p),
        sdk_all_boxes_cl(p))]$
weakpl_sdk_stdfcl(p) := standardise_sdk(weakpl_sdk_fcl(p),p)$
weakpl_sdk_fcs(p) := fcl2fcs(weakpl_sdk_fcl(p))$
weakpl_sdk_stdfcs(p) := fcl2fcs(weakpl_sdk_stdfcl(p))$

weakpb_sdk_fcl(p) := [var_sdk(p), 
 append(sdk_different_rows_cl(p), 
        sdk_different_columns_cl(p),
        sdk_different_boxes_cl(p),
        sdk_all_fields_cl(p),
        sdk_different_fields_cl(p))]$
weakpb_sdk_stdfcl(p) := standardise_sdk(weakpb_sdk_fcl(p),p)$
weakpb_sdk_fcs(p) := fcl2fcs(weakpb_sdk_fcl(p))$
weakpb_sdk_stdfcs(p) := fcl2fcs(weakpb_sdk_stdfcl(p))$

output_weakpl_sdk(p,filename) := block([FF : weakpl_sdk_stdfcl(p)],
  output_fcl_v(
    sconcat(
"The Sudoku problem (weak-pl form) with box-dimension ", p, ".
c Generated by the OKlibrary at Maxima-level."),
    FF,
    filename,
    []))$
output_weakpl_sdk_stdname(p) := 
  output_weakpl_sdk(p,sconcat("WeakPl_Sudoku_Box_dim_",p,".cnf"))$

output_weakpb_sdk(p,filename) := block([FF : weakpb_sdk_stdfcl(p)],
  output_fcl_v(
    sconcat(
"The Sudoku problem (weak-pb form) with box-dimension ", p, ".
c Generated by the OKlibrary at Maxima-level."),
    FF,
    filename,
    []))$
output_weakpb_sdk_stdname(p) := 
  output_weakpb_sdk(p,sconcat("WeakPb_Sudoku_Box_dim_",p,".cnf"))$


/* The dual weak form, plus either the long or the binary clauses from the
   weak form:
*/

dual_weakpl_sdk_fcl(p) := [var_sdk(p), 
 append(sdk_all_rows_cl(p),
        sdk_all_columns_cl(p),
        sdk_all_boxes_cl(p),
        sdk_different_fields_cl(p),
        sdk_all_fields_cl(p))]$
dual_weakpl_sdk_stdfcl(p) := standardise_sdk(dual_weakpl_sdk_fcl(p),p)$
dual_weakpl_sdk_fcs(p) := fcl2fcs(dual_weakpl_sdk_fcl(p))$
dual_weakpl_sdk_stdfcs(p) := fcl2fcs(dual_weakpl_sdk_stdfcl(p))$

dual_weakpb_sdk_fcl(p) := [var_sdk(p), 
 append(sdk_all_rows_cl(p),
        sdk_all_columns_cl(p),
        sdk_all_boxes_cl(p),
        sdk_different_fields_cl(p),
        sdk_different_rows_cl(p),
        sdk_different_columns_cl(p),
        sdk_different_boxes_cl(p))]$
dual_weakpb_sdk_stdfcl(p) := standardise_sdk(dual_weakpb_sdk_fcl(p),p)$
dual_weakpb_sdk_fcs(p) := fcl2fcs(dual_weakpb_sdk_fcl(p))$
dual_weakpb_sdk_stdfcs(p) := fcl2fcs(dual_weakpb_sdk_stdfcl(p))$

output_dual_weakpl_sdk(p,filename) := block([FF : dual_weakpl_sdk_stdfcl(p)],
  output_fcl_v(
    sconcat(
"The Sudoku problem (dual_weak-pl form) with box-dimension ", p, ".
c Generated by the OKlibrary at Maxima-level."),
    FF,
    filename,
    []))$
output_dual_weakpl_sdk_stdname(p) := 
  output_dual_weakpl_sdk(p,sconcat("Dual_WeakPl_Sudoku_Box_dim_",p,".cnf"))$

output_dual_weakpb_sdk(p,filename) := block([FF : dual_weakpb_sdk_stdfcl(p)],
  output_fcl_v(
    sconcat(
"The Sudoku problem (dual_weak-pb form) with box-dimension ", p, ".
c Generated by the OKlibrary at Maxima-level."),
    FF,
    filename,
    []))$
output_dual_weakpb_sdk_stdname(p) := 
  output_dual_weakpb_sdk(p,sconcat("Dual_WeakPb_Sudoku_Box_dim_",p,".cnf"))$


/* ************
   * Measures *
   ************
*/

/* Number of variables: */
nvar_sdk(p) := p^6$

/* List of clause-counts for weak_sdk as with ncl_list_fcl: */
ncl_list_weak_sdk_fcl(p) := if p = 0 then [] elseif p = 1 then [[1,1]] else
 block([N : p^2], return([ [2, 3 * N^2 * binomial(N,2)], [N, N^2] ]))$
ncl_list_weak_sdk_fcs(p) := if p = 0 then [] elseif p = 1 then [[1,1]] else
 block([N : p^2], return([ [2, 3 * N^2 * binomial(N,2) - N^2 * N * (p-1)], [N, N^2] ]))$
/* List of clause-counts for dual_weak_sdk as with ncl_list: */
ncl_list_dual_weak_sdk_fcl(p) := if p = 0 then [] elseif p = 1 then [[1,3]] else
 block([N : p^2], return([[2, N^2 * binomial(N,2)], [N, 3 * N^2]]))$
ncl_list_dual_weak_sdk_fcs(p) := if p = 0 then [] elseif p = 1 then [[1,1]] else
 block([N : p^2], return([[2, N^2 * binomial(N,2)], [N, 3 * N^2]]))$
/* List of clause-counts for strong_sdk as with ncl_list: */
ncl_list_strong_sdk_fcl(p) := if p = 0 then [] elseif p = 1 then [[1,4]] else
 block([N : p^2], return([ [2, 4 * N^2 * binomial(N,2)], [N, 4 * N^2] ]))$
ncl_list_strong_sdk_fcs(p) := if p = 0 then [] elseif p = 1 then [[1,1]] else
 block([N : p^2], return([ [2, 4 * N^2 * binomial(N,2) - N^2 * N * (p-1)], [N, 4 * N^2] ]))$

/* Total number of clauses: */
ncl_weak_sdk_fcl(p) := block([L : ncl_list_weak_sdk_fcl(p)],
 return(sum_l(map(second,L))))$
ncl_weak_sdk_fcs(p) := block([L : ncl_list_weak_sdk_fcs(p)],
 return(sum_l(map(second,L))))$
ncl_dual_weak_sdk_fcl(p) := block([L : ncl_list_dual_weak_sdk_fcl(p)],
 return(sum_l(map(second,L))))$
ncl_dual_weak_sdk_fcs(p) := block([L : ncl_list_dual_weak_sdk_fcs(p)],
 return(sum_l(map(second,L))))$
ncl_strong_sdk_fcl(p) := block([L : ncl_list_strong_sdk_fcl(p)],
 return(sum_l(map(second,L))))$
ncl_strong_sdk_fcs(p) := block([L : ncl_list_strong_sdk_fcs(p)],
 return(sum_l(map(second,L))))$


/* Number of literal occurrences: */
nlitocc_weak_sdk_fcl(p) := block([L : ncl_list_weak_sdk_fcl(p)],
 return(sum_l(map("*",map(first,L),map(second,L)))))$
nlitocc_weak_sdk_fcs(p) := block([L : ncl_list_weak_sdk_fcs(p)],
 return(sum_l(map("*",map(first,L),map(second,L)))))$
nlitocc_dual_weak_sdk_fcl(p) := block([L : ncl_list_dual_weak_sdk_fcl(p)],
 return(sum_l(map("*",map(first,L),map(second,L)))))$
nlitocc_dual_weak_sdk_fcs(p) := block([L : ncl_list_dual_weak_sdk_fcs(p)],
 return(sum_l(map("*",map(first,L),map(second,L)))))$
nlitocc_strong_sdk_fcl(p) := block([L : ncl_list_strong_sdk_fcl(p)],
 return(sum_l(map("*",map(first,L),map(second,L)))))$
nlitocc_strong_sdk_fcs(p) := block([L : ncl_list_strong_sdk_fcs(p)],
 return(sum_l(map("*",map(first,L),map(second,L)))))$


/* ********************
   * Creating puzzles *
   ********************
*/

/* For the direct encoding */

/* Field settings as unit-clauses, already standardised. Input is a list L
   of triples [i,j,k], meaning that field [i,j] carries number k.
   Prerequisite is that all fields are in range allowed by p.
*/
sdk_fields_stdcl(L,p) := map(set, map(lambda([t],standardise_sdk(t,p)),map(lambda([t],apply(sdk_var,t)), L)))$

/* Output a complete Sudoku problem ("puzzle") to a file, using the strong
   translation:
*/
output_sdk_puzzle(p,L,comment,filename) := block(
 [FF : strong_sdk_stdofcs(p),
  F : sdk_fields_stdcl(L,p)],
  output_fcl_v(
    sconcat(
"The Sudoku problem (strong form) with box-dimension ", p, ", and with additional fields set.
c Generated by the OKlibrary at Maxima-level.
c ", comment),
    [FF[1], append(FF[2],F)],
    filename,
    []))$

/* Some special cases: */

EasterMonster : [
 [1,1,1],[1,9,2],
 [2,2,9],[2,4,4],[2,8,5],
 [3,3,6],[3,7,7],
 [4,2,5],[4,4,9],[4,6,3],
 [5,5,7],
 [6,4,8],[6,5,5],[6,8,4],
 [7,1,7],[7,7,6],
 [8,2,3],[8,6,9],[8,8,8],
 [9,3,2],[9,9,1]]$

output_sdk_EasterMonster() :=
 output_sdk_puzzle(3,EasterMonster,"Problem EasterMonster in [The Hidden Logic of Sudoku, Berthier].","S_EasterMonster.cnf")$


/*!
\endhtmlonly
*/
