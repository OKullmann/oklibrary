/* Oliver Kullmann, 12.2.2008 (Swansea) */
/* Copyright 2008 Oliver Kullmann
This file is part of the OKlibrary. OKlibrary is free software; you can redistribute
it and/or modify it under the terms of the GNU General Public License as published by
the Free Software Foundation and included in this library; either version 3 of the
License, or any later version. */

/*!
  \file ComputerAlgebra/Satisfiability/Lisp/ConflictCombinatorics/HittingClauseSets.mac
  \brief Functions related to hitting clause-sets and generalisations

Use by

oklib_load("Transitional/ComputerAlgebra/Satisfiability/Lisp/ConflictCombinatorics/HittingClauseSets.mac");

*/

/*!
\htmlonly
*/

oklib_include("Transitional/ComputerAlgebra/Satisfiability/Lisp/Backtracking/SplittingTrees.mac");
oklib_include("Transitional/ComputerAlgebra/Satisfiability/Lisp/Generators/Generators.mac");
oklib_include("Transitional/ComputerAlgebra/Satisfiability/Lisp/ClauseSets/Hypergraphs.mac");
oklib_include("Transitional/ComputerAlgebra/Hypergraphs/Lisp/SetSystems.mac");
oklib_include("Transitional/ComputerAlgebra/Satisfiability/Lisp/ClauseSets/BasicOperations.mac");
oklib_include("Transitional/ComputerAlgebra/Graphs/Lisp/Basic.mac");
oklib_include("Transitional/ComputerAlgebra/Satisfiability/Lisp/Backtracking/DLL_solvers.mac")$
oklib_include("Transitional/ComputerAlgebra/Satisfiability/Lisp/Counting/InclusionExclusion.mac");


/* ***************************************
   * Representations via splitting trees *
   ***************************************
*/

/* Given a splitting tree (a tree whose inner nodes are labelled by boolean
   literals), extract the hitting clause-set given by the false-leaves
   (which is unsatisfiable iff the tree is complete; the "clause-set" 
   contains a tautological clause (this for the CNF interpretation) iff a 
   variable occurs twice on some  path). */
/* The unsatisfiable hitting clause-sets generated in this way are the
   "tree hitting clause-sets", and with tautological clauses removed these
   are exactly those hitting clause-sets which have a read-once resolution 
   refutation.
   The other hitting clause-sets created are subsets of tree hitting 
   clause-sets. */
treehittingcls_st(T) := setify(usat_clauses_st(T))$
/* The dual hitting clause-set, representing the unterlying CNF as DNF */
dualtreehittingcls_st(T) := setify(sat_pass_st(T))$
/* The full representation, consisting of a hitting clause-set representing
   the falsifying assignments (as CNF), and of a hitting clause-set 
   representing the satisfying assignments (as DNF, i.e. as sets of
   partial assignments). */
hitting_cls_rep_st(T) := [treehittingcls_st(T), dualtreehittingcls_st(T)]$

/* Convenience functions, which generate splitting trees by backtracking
   solvers (without backtracking); the heuristics needs to be
   supplied). */
treehittingcls_fcs(FF,h) := treehittingcls_st(dll_simplest_st(FF,h))$
dualtreehittingcls_fcs(FF,h) := dualtreehittingcls_st(dll_simplest_st(FF,h))$
hitting_cls_rep_fcs(FF,h) := hitting_cls_rep_st(dll_simplest_st(FF,h))$


/* **************
   * Generators *
   **************
*/

/* An unsatisfiable uniform clause-set F with clause-length k has at least
   2^k clauses, and the minimum is attained exactly for the uniform hitting
   clause-sets with clause-length k and 2^k clauses. */
/* The two extreme cases are given by full_fcs(n) (with maximal deficiency)
   and by the following special SMUSAT(1) clause-sets (with minimal 
   deficiency), which are (up to renaming) exactly the uniform elements of
   SMUSAT(1) with clause-length k. */
uniform_usat_hitting_min(k) := treehittingcls_st(complete_st_alldifferent(k))$
uniform_usat_hitting_max(k) := full_fcs(k)[2]$

/* Saturated minimally unsatisfiable Horn clause-sets with k variables */
smusat_horn(k) := treehittingcls_st(horn_st(k))$


/* Example from [Savicky, Sgall, 2000, DNF tautologies with a limited number
   of occurrences of every variable] */
sasg2000 : [setn(4), {{1,-2,4},{2,-3,4},{-1,3,4},{1,2,3},
 {1,-2,-4},{2,-3,-4},{-1,3,-4},{-1,-2,-3}}]$
/* Example from [Brouwer, 1999, An associative block design ABD(8,5) */
brouwer1999 : [setn(8), {
 {1,2,3,4,5},{-1,2,3,4,5},{1,2,3,4,-5},{-1,2,3,4,-5},
 {1,2,3,-4,6},{-1,2,3,-4,6},{1,-4,5,-6,7},{-1,-4,5,-6,7},
 {2,-4,-6,-7,8},{3,-4,-6,-7,-8},{1,-4,-5,-6,7},{-1,-4,-5,-6,7},
 {1,-3,5,6,8},{-1,-3,5,6,8},{2,-3,4,7,-8},{1,-3,5,-7,-8},{-1,-3,5,-7,-8},
 {2,-3,4,-6,8},{2,-3,-5,6,8},{1,-3,-5,-7,-8},{-1,-3,-5,-7,-8},
 {-3,-4,6,7,-8},{-2,3,5,6,8},{-2,4,6,7,-8},{-2,3,4,-7,-8},
 {1,-2,4,-6,7},{-1,-2,4,-6,7},{-2,5,-6,-7,8},{-2,-5,6,7,8},
 {1,-2,-5,-7,8},{-1,-2,-5,-7,8},{-2,3,-4,6,-8}}]$


/* *********
   * Tests *
   *********
*/

/* SAT decision for hitting clause-sets */
sat_decision_hitting_cs(F) := is(satprob_hitting(F) > 0)$

/* Tests whether a clause-set is a hitting clause-set */
hittingcsp(F) := block([l : length(F), L : listify(F), break : false],
  for i : 1 thru l-1 unless break do for j : i+1 thru l unless break do
    if not clashp(L[i], L[j]) then break : true,
  return(not break))$
/* hittingcsp(F) = completegrp(cg_cs(F)) */
/* Also: hittingcsp(F) iff independence_number_cs(F) <= 1. */

/* Tests whether a clause-set is a tree hitting clause-set */
treehittingcsp(F) := block([G : var_hyp(cs_to_fcs(F))],
  if emptyp(G[1]) then return(is(F = {{}}))
  else block([D : apply(intersection, listify(G[2])), v],
    if emptyp(D) then return(false)
    else (
      v : listify(D)[1],
      return(
        treehittingcsp(apply_pa({v},F)) and treehittingcsp(apply_pa({-v},F))))))$

/* Tests whether a clause-set is a uniform unsatisfiable hitting clause-set */
uuhittingcsp(F) := 
 hittingcsp(F) and uniformcsp(F) and not emptyp(F) and is(ncl_cs(F) = 2^(length(listify(F)[1])))$

/* Returns false if F is not an ABD, and otherwise returns (n,k) */
abd_parameters(F) := 
 if not uuhittingcsp(F) or not variableregularcsp(F) then false
 else [nvar_cs(F), length(listify(F)[1])]$


/* ****************************************************
   * Representing clause-sets via hitting clause-sets *
   ****************************************************
*/

/* Decomposition into a list of hitting clause-sets via the Maxima
   function max_clique; simple greedy approach by grabbing the largest
   clique. */
/* The length of the returned list is an upper bound on the partition
   number of the conflict graph. */
hitting_decomposition_m_cs(F) := block([G : g2mg(cg_cs(F)), G2, R : []],
 G2 : copy_graph(G),
 while graph_size(G2) > 0 do block([M : max_clique(G2)],
   R : endcons(setify(M), R),
   for v in M do remove_vertex(v, G2)),
 map(lambda([M],map(lambda([v],get_vertex_label(v,G)),M)), R))$

/*!
\endhtmlonly
*/
