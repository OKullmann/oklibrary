/* Matthew Gwynne, 26.3.2008 (Swansea) */
/* Copyright 2008, 2009, 2010, 2011 Oliver Kullmann
This file is part of the OKlibrary. OKlibrary is free software; you can redistribute
it and/or modify it under the terms of the GNU General Public License as published by
the Free Software Foundation and included in this library; either version 3 of the
License, or any later version. */

/*!
  \file ComputerAlgebra/Cryptology/Lisp/Cryptanalysis/Rijndael/Translations.mac
  \brief Cryptanalysis functions for translations of Rijndael into active clauses etc

Use by

oklib_load("OKlib/ComputerAlgebra/Cryptology/Lisp/Cryptanalysis/Rijndael/Translations.mac");

*/

/*!
\htmlonly
*/

oklib_include("OKlib/ComputerAlgebra/DataStructures/Lisp/Lists.mac")$
oklib_include("OKlib/ComputerAlgebra/Cryptology/Lisp/CryptoSystems/Rijndael/AdvancedEncryptionStandard.mac")$
oklib_include("OKlib/ComputerAlgebra/Cryptology/Lisp/Cryptanalysis/Rijndael/SboxAnalysis.mac")$
oklib_include("OKlib/ComputerAlgebra/Cryptology/Lisp/Cryptanalysis/Rijndael/FieldOperationsAnalysis.mac")$
oklib_include("OKlib/ComputerAlgebra/Cryptology/Lisp/Cryptanalysis/Rijndael/data/FieldMul2CNF.mac")$
oklib_include("OKlib/ComputerAlgebra/Cryptology/Lisp/Cryptanalysis/Rijndael/data/FieldMul3CNF.mac")$
oklib_include("OKlib/ComputerAlgebra/Cryptology/Lisp/Cryptanalysis/Rijndael/data/FieldMul11CNF.mac")$
oklib_include("OKlib/ComputerAlgebra/Cryptology/Lisp/Cryptanalysis/Rijndael/data/FieldMul13CNF.mac")$
oklib_include("OKlib/ComputerAlgebra/Cryptology/Lisp/Cryptanalysis/Rijndael/data/FieldMul14CNF.mac")$
oklib_include("OKlib/ComputerAlgebra/Cryptology/Lisp/Cryptanalysis/Rijndael/data/FieldMul9CNF.mac")$
oklib_include("OKlib/ComputerAlgebra/Cryptology/Lisp/Cryptanalysis/Rijndael/data/SboxCNF.mac")$
oklib_include("OKlib/ComputerAlgebra/Satisfiability/Lisp/FiniteFunctions/TseitinTranslation.mac")$
oklib_include("OKlib/ComputerAlgebra/Cryptology/Lisp/Cryptanalysis/Rijndael/ConstraintTemplateGlobalPropagation.mac")$
oklib_include("OKlib/ComputerAlgebra/Cryptology/Lisp/Cryptanalysis/Rijndael/ConstraintTemplateRewriteSystem.mac")$
oklib_include("OKlib/ComputerAlgebra/Cryptology/Lisp/Cryptanalysis/Rijndael/ConstraintTemplateSmallScaleRewriteRules.mac")$
oklib_include("OKlib/ComputerAlgebra/Cryptology/Lisp/Cryptanalysis/Rijndael/ConstraintTemplateTranslation.mac")$

/* TODO: Add documentation at this level. */


/* ***************************************
   * Sets of Conditions                  *
   ***************************************
*/


/* Generates (and caches) the canonical CNF representation as a formal clause
   set of AES Field muliplication (within the Rijndael GF(2^8) field) by p 
   (given as an integer) with new variables. 
   
   New variables are introduced for each clause in the canonical DNF 
   representation (see dualts_fcl), where the variables are of the form dts(i)
   and i is the rank in the lexiographical ordering of the clauses.

   Caching here simply means that upon the first call to the function with
   argument "p", the result of the computation for that argument is stored 
   in a global variable "aes_mul_ts_CNF[p]" which will then be returned 
   immediately on subsequent calls to "aes_mul_ts_gen" with the same argument 
   to allow for reuse of "aes_mul_ts_gen" without the overhead of 
   recomputation.
 */
aes_mul_ts_CNF : create_list(false,i,1,256)$
aes_mul_ts_gen(p) := 
  if aes_mul_ts_CNF[p+1] = false then block([plus16 : lambda([x],x+16)],
      [mul_dnf : rijnmult_fulldnf_fcs(p)],
    aes_mul_ts_CNF[p+1] : dualts_fcl(
      [listify(mul_dnf[1]),
       sort(
         listify(mul_dnf[2]),
         lambda([a,b], is(
           rank_lex_ksubsets(map(plus16,a),32) < 
             rank_lex_ksubsets(map(plus16,b),32)))
        )]
     ),
     return(aes_mul_ts_CNF[p+1])
  ) else aes_mul_ts_CNF[p+1]$

/* Generates (and caches) the canonical CNF representation as a formal clause
   set of AES Sbox operator with new variables. New variables are 
   introduced for each clause in the canonical DNF representation (see
   dualts_fcl), where the new variables are of the form dts(i) and i is the 
   rank in the lexiographical ordering of the clauses.

   Caching here simply means that upon the first call to the function, the
   result of the computation is stored in a global variable "aes_sbox_ts_CNF"
   which will then be returned immediately on subsequent calls to
   "aes_sbox_ts_gen" to allow for reuse of "aes_sbox_ts_gen" without the
   overhead of recomputation.
 */
aes_sbox_ts_CNF : false;
aes_sbox_ts_gen() :=
  if aes_sbox_ts_CNF = false then block([plus16 : lambda([x],x+16)],
      [sbox_dnf : rijnsbox_fulldnf_fcs()],
    aes_sbox_ts_CNF : dualts_fcl(
      [listify(sbox_dnf[1]),
       sort(
         listify(sbox_dnf[2]),
         lambda([a,b], is(
           rank_lex_ksubsets(map(plus16,a),32) <
             rank_lex_ksubsets(map(plus16,b),32)))
        )]
     ),
     return(aes_sbox_ts_CNF)
  ) else aes_sbox_ts_CNF$


/*************************************************************
 * Constraint template rewrite-based translations            *
 *************************************************************
*/

oklib_include("OKlib/ComputerAlgebra/Cryptology/Lisp/Cryptanalysis/Rijndael/ConstraintTemplateRewriteRules.mac");
oklib_include("OKlib/ComputerAlgebra/Cryptology/Lisp/Cryptanalysis/Rijndael/ConstraintTemplateRewriteSystem.mac");


/* AES */

/* AES Translations

         Boxes -
             For each box we have the following translation

             aes_small_box - Each box is represented by the smallest known cnf
             aes_ts_box    - Each box is represented by the canonical
                             translation using new variables.
             aes_rbase_box - Each box is represented by a CNF which is
                             an r_1 base.

         MixColumns -
             For the translation of the MixColumns component, we may either
             add additional constraints translating the inversion as well
             or simply translate the component in the forward direction.

             aes_mc_forward
             aes_mc_bidirectional

*/

declare(aes_small_box, noun)$
declare(aes_full_box, noun)$
declare(aes_ts_box, noun)$
declare(aes_rbase_box, noun)$
declare(aes_mc_forward, noun)$
declare(aes_mc_bidirectional, noun)$
declare(aes_combined_box, noun)$
declare(aes_core_round_box, noun)$
declare(aes_mc_boolm, noun)$
declare(aes_mc_box, noun)$


/* Constraint rewrite translations */

/* Given the number of rounds, produces a list of constraint templates
   which model AES using standard parameters. */
/* TODO: Add the full version that allows all parameters */
aes_csttl(r, mc_tran) :=
  rewrite_all_csttl(
    [cstt_new("aes_cst",
              generate_aes_constraint_vars(1,3*128,cstt_id_ns,"aes_cst"),
              [r],cstt_id_ns)],
    if mc_tran = aes_mc_bidirectional then aes_bimc_rewrite_mapping_std
    else aes_rewrite_mapping_std)$
aes_cstt_std_l(r) := aes_csttl(r, aes_mc_forward)$


aes_cstt_vars_l(r, mc_tran) :=
  append(
    generate_aes_constraint_vars(1,3*128,cstt_id_ns,"aes_cst"),
    rewrite_all_cstt_vars_l(
      [cstt_new("aes_cst",
        generate_aes_constraint_vars(1,3*128,cstt_id_ns,"aes_cst"),
        [r],cstt_id_ns)],
      if mc_tran = aes_mc_bidirectional then aes_bimc_rewrite_mapping_std
      else aes_rewrite_mapping_std))$
aes_cstt_vars_std_l(r) := aes_cstt_vars_l(r,aes_mc_forward)$


aes_fcl(r, box_tran, mc_tran) := block(
  [aes_csttl : aes_csttl(r,mc_tran),aes_vars_l, prop_csttl],
  aes_vars_l : aes_cstt_vars_l(r,mc_tran),
  prop_csttl : prop_all_csttl(aes_csttl, aes_vars_l, aes_propagations),
  csttl2fcl(prop_csttl[1],prop_csttl[2],
    if box_tran = aes_small_box then
      aes_pi_translation_mapping
    else
      aes_ts_translation_mapping))$

aes_std_fcl(r) := aes_fcl(r, aes_small_box, aes_ts_box)$

/* Small Scale AES */

ss_csttl(r,ss_num_columns, ss_num_rows, ss_exp, final_round_b, mc_tran) :=
  block([num_block_bits : ss_num_columns * ss_num_rows * ss_exp],
    rewrite_all_csttl(
      [cstt_new("ss_cst",
        generate_aes_constraint_vars(1,3*num_block_bits,
          cstt_id_ns,"ss_cst"),
          [r,ss_num_columns, ss_num_rows,2, ss_exp,
           ss_polynomial(2,ss_exp),ss_sbox_matrix(2,ss_exp),
           ss_affine_constant(2,ss_exp),
           ss_mixcolumns_matrix(2,ss_exp,ss_num_rows),final_round_b],
           cstt_id_ns)],
    if mc_tran = aes_mc_bidirectional then ss_bimc_rewrite_mapping_std
    else if mc_tran = aes_mc_boolm then ss_boolm_rewrite_mapping_std
    else if mc_tran = aes_mc_box then ss_boxmc_rewrite_mapping_std
    else if mc_tran = aes_combined_box then ss_boxcombined_rewrite_mapping_std
    else if mc_tran = aes_core_round_box then ss_round_column_rewrite_mapping_std
    else ss_rewrite_mapping_std))$
/*aes_cstt_std_l(r) := aes_csttl(r, aes_mc_forward)$*/

ss_cstt_vars_l(r, ss_num_columns, ss_num_rows, ss_exp, final_round_b, mc_tran) :=
  append(
    generate_aes_constraint_vars(1,3*(ss_num_columns*ss_num_rows*ss_exp),
        cstt_id_ns,"ss_cst"),
    rewrite_all_cstt_vars_l(
      [cstt_new("ss_cst",
        generate_aes_constraint_vars(1,3*(ss_num_columns*ss_num_rows*ss_exp),
          cstt_id_ns,"ss_cst"),
        [r,ss_num_columns, ss_num_rows,2, ss_exp,
           ss_polynomial(2,ss_exp),ss_sbox_matrix(2,ss_exp),
           ss_affine_constant(2,ss_exp),
           ss_mixcolumns_matrix(2,ss_exp,ss_num_rows),final_round_b],
           cstt_id_ns)],
      if mc_tran = aes_mc_bidirectional then ss_bimc_rewrite_mapping_std
      else if mc_tran = aes_mc_boolm then ss_boolm_rewrite_mapping_std
      else if mc_tran = aes_mc_box then ss_boxmc_rewrite_mapping_std
      else if mc_tran = aes_combined_box then ss_boxcombined_rewrite_mapping_std
      else if mc_tran = aes_core_round_box then ss_round_column_rewrite_mapping_std
      else ss_rewrite_mapping_std))$

ss_fcl(r, ss_num_columns, ss_num_rows, ss_exp, final_round_b, box_tran, mc_tran) := block(
  [ss_csttl : ss_csttl(r,ss_num_columns, ss_num_rows, ss_exp, final_round_b,mc_tran),
  ss_vars_l, prop_csttl],
  ss_vars_l : ss_cstt_vars_l(r,ss_num_columns,
      ss_num_rows, ss_exp, final_round_b,mc_tran),
  prop_csttl : prop_all_csttl(ss_csttl, ss_vars_l, ss_propagations),
  csttl2fcl(prop_csttl[1],prop_csttl[2],
    if box_tran = aes_small_box then
      ss_pi_translation_mapping
    else if box_tran = aes_rbase_box then
      ss_rbase_translation_mapping
    else if box_tran = aes_full_box then
      ss_full_translation_mapping
    else
      ss_ts_translation_mapping))$

output_ss_fcl(name,r, ss_num_columns, ss_num_rows, ss_exp, final_round_b, box_tran, mc_tran) :=
  block([FF, FF_std],
    if oklib_monitor then print("Starting translation..."),
    FF : ss_fcl(r, ss_num_columns, ss_num_rows, ss_exp, final_round_b, box_tran, mc_tran),
    if oklib_monitor then print("Starting standardisation..."),
    FF_std : standardise_fcl(FF),
    if oklib_monitor then print("Starting output..."),
    output_fcl_v(sconcat("Small Scale AES with ",
                   "r=",r,",c=",ss_num_columns,",rw=",ss_num_rows,
                   ",e=",ss_exp,",final=",final_round_b,
                   ",box_tran=",box_tran,",mc_tran=",mc_tran),
                 FF_std[1],name,
      FF_std[2]))$

/* Computing and outputting AES translations using caching: */
output_fast_ss_fcl(name,r, ss_num_columns, ss_num_rows, ss_exp, final_round_b, box_tran, mc_tran) :=
  block([FF, FF_std],
    local(gen_count, generate_ss_constraint_vars, rename_fcl, gen_h, gen_inv_h),
    /* Defining a faster rename_fcl function, hashing using arrays: */
    rename_fcl(FF,VL) := block([count : -1], local(h),
      for V in map("[", FF[1], VL) do h[V[1]] : V[2],
      return([create_list(i,i,1,length(FF[1])),
        map(
          lambda([C], (
              if oklib_monitor then
              (count : count + 1,
                if mod(count,1000) = 0 then
                print("Renaming ", count, "/",length(FF[2]))),
              map(lambda([L], if L > 0 then h[L] else -h[-L]), C))), FF[2])])),
    /* Defining a faster variable naming scheme, using integer variables
       and storing the mapping in hash (as an array): */
    gen_count : 1,
    generate_ss_constraint_vars(n,m,namespace, id) :=
      create_list(
        if integerp(gen_h[namespace(ss_var(i,id))]) then gen_h[namespace(ss_var(i,id))]
        else (
          gen_h[namespace(ss_var(i,id))] : (gen_count : gen_count +1),
          gen_inv_h[gen_count] : namespace(ss_var(i,id)),
          gen_count),
        i,n,m),
    if oklib_monitor then print("Starting translation..."),
    FF : ss_fcl(r, ss_num_columns, ss_num_rows, ss_exp, final_round_b, box_tran, mc_tran),
    if oklib_monitor then print("Starting standardisation..."),
    FF_std : standardise_fcl(FF),
    if oklib_monitor then print("Computing correct variable names..."),
    FF_std : [FF_std[1],
      prop_eq_lift_renaming(FF_std[2],
        buildq([gen_inv_h], lambda([a], if atom(a) then gen_inv_h[a] else a)))],
    if oklib_monitor then print("Starting output..."),
    output_fcl_v(sconcat("Small Scale AES with ",
                   "r=",r,",c=",ss_num_columns,",rw=",ss_num_rows,
                   ",e=",ss_exp,",final=",final_round_b,
                   ",box_tran=",box_tran,",mc_tran=",mc_tran),
                 FF_std[1],name,
      FF_std[2]))$
/* This function makes the following assumptions:
    - The order of the variable list returned in ss_fcl doesn't
      depend on the variable names it uses for its auxilliary variables.
    - The function ss_fcl uses the function generate_ss_constraint_vars
      to generate new auxilliary variables.
    - When a clause-set is renamed by ss_fcl, rename_fcl is used.
*/
  
output_ss_fcl_std(r, ss_num_columns, ss_num_rows, ss_exp, final_round_b, box_tran, mc_tran) :=
  output_ss_fcl(
    sconcat("ssaes_r", r, "_c",ss_num_columns, "_rw",ss_num_rows,"_e",ss_exp,
      "_f",if final_round_b then 1 else 0, "_", box_tran, "_", mc_tran, ".cnf"),
    r, ss_num_columns, ss_num_rows, ss_exp, final_round_b, box_tran, mc_tran)$
output_fast_ss_fcl_std(r, ss_num_columns, ss_num_rows, ss_exp, final_round_b, box_tran, mc_tran) :=
  output_fast_ss_fcl(
    sconcat("ssaes_r", r, "_c",ss_num_columns, "_rw",ss_num_rows,"_e",ss_exp,
      "_f",if final_round_b then 1 else 0,"_",box_tran, "_", mc_tran,".cnf"),
    r, ss_num_columns, ss_num_rows, ss_exp, final_round_b, box_tran, mc_tran)$
    

ss_trans_fcl(cst, box_tran, mc_tran) := block(
  [ss_csttl,ss_vars_l, prop_csttl,rm],
  rm :
    if mc_tran = aes_mc_bidirectional then ss_bimc_rewrite_mapping_std
    else if mc_tran = aes_mc_boolm then ss_boolm_rewrite_mapping_std
    else if mc_tran = aes_mc_box then ss_boxmc_rewrite_mapping_std
    else if mc_tran = aes_combined_box then ss_boxcombined_rewrite_mapping_std
    else if mc_tran = aes_core_round_box then ss_round_column_rewrite_mapping_std
    else ss_rewrite_mapping_std,
  ss_csttl : rewrite_all_csttl([cst],ss_rewrite_mapping_std),
  ss_vars_l : append(cstt_vars_l(cst),rewrite_all_cstt_vars_l([cst], rm)),
  prop_csttl : prop_all_csttl(ss_csttl, ss_vars_l, ss_propagations),
  csttl2fcl(prop_csttl[1],prop_csttl[2],
    if box_tran = aes_small_box then
      ss_pi_translation_mapping
    else
      ss_ts_translation_mapping))$


/**************************************************************
 * Special output formats                                     *
 **************************************************************
*/

/* Generates a Dimacs CNF file and a file containing XOR clauses
   where together the files are a translation of the verification
   of the AES cipher specified by the given parameters.

   Inputs:
     n (string)
       The file to output the Dimacs CNF to.
     r (positive integer)
       The number of rounds in the AES variant to translate.
     ss_num_columns (positive integer)
       The number of columns in the AES variant block.
     ss_num_rows ({1,2,4})
       The number of rows in the AES variant block.
     ss_exp (positive integer)
       The exponent of the GF(2^ss_exp) finite field the AES variant
       is defined over.
     final_round_b (boolean)
       Whether or not the AES variant has a special final round consisting
       of only key addition, SubBytes and ShiftRows.
     box_tran ({aes_small_box, aes_ts_box, aes_rbase_box})
       How to translate the "small components" of the AES cipher to CNF:
       using the smallest known representation (aes_small_box), the canonical
       translation using new variables (aes_ts_box) or the smallest known
       r_1-base (aes_rbase_box).
     mc_tran
       How to translate the MixColumn operation of the AES cipher:
       translating the MixColumn in the encryption direction
       (aes_mc_forward), translating the MixColumn in the encryption and
       decryption direction (aes_mc_bidirectional), translating the
       MixColumn directly as a series of addition constraints at the
       bit-level (aes_mc_boolm), or translating the MixColumn operation
       as one box (aes_mc_box).

  Outputs:
    Two files are output:
      name
        A Dimacs CNF file containing the CNF translation of the AES cipher
        specified by the parameters, excluding any addition constraints
        generated by the translation.
      n_xor
        All addition constraints generated by the translation of the
        AES cipher specified by the parameters, given in the form

        x1 2 ... -n 0

        representing v_1 + ... + v_(n-1) = v_n (i.e., v_1, ..., -v_n as a
        whole have odd parity). This input format is supported by
        the cryptominisat solver, which has the additional command line
        option "--alsoread", allowing one to pass these XOR clauses to
        the solver from a separate file.
*/
output_ss_fcl_wxor(name,r, ss_num_columns, ss_num_rows, ss_exp, final_round_b, box_tran, mc_tran) :=
block(
  [ss_csttl : ss_csttl(r,ss_num_columns, ss_num_rows, ss_exp, final_round_b,mc_tran),
  ss_vars_l, prop_csttl, xor_csttl, FF],
  ss_vars_l : ss_cstt_vars_l(r,ss_num_columns,
      ss_num_rows, ss_exp, final_round_b,mc_tran),
  prop_csttl : prop_all_csttl(ss_csttl, ss_vars_l, ss_propagations),
  [xor_csttl,prop_csttl[1]] :
    partition_list(prop_csttl[1],lambda([a],is(cstt_name(a) = "ss_add_cst"))),
  FF : csttl2fcl(prop_csttl[1],prop_csttl[2],
    if box_tran = aes_small_box then
      ss_pi_translation_mapping
    else if box_tran = aes_rbase_box then
      ss_rbase_translation_mapping
    else
      ss_ts_translation_mapping),
  if oklib_monitor then print("Starting standardisation..."),
  FF_std : standardise_fcl(FF),
  xor_csttl : csttl_rename_vars(xor_csttl,FF_std[2],FF_std[1][1]),
  if oklib_monitor then print("Starting output of clauses..."),
  output_fcl_v(sconcat("Small Scale AES with ",
                 "r=",r,",c=",ss_num_columns,",rw=",ss_num_rows,
                 ",e=",ss_exp,",final=",final_round_b,
                 ",box_tran=",box_tran,",mc_tran=",mc_tran),
               FF_std[1],name,
    FF_std[2]),
  if oklib_monitor then print("Starting output of xor clauses..."),
  /* Each ss_add_cst constraint stands for nb additions of m variables
     where the (j+1)-th variable in the i-th addition is the (j*nb+i)-th
     variable in the ss_add_cst variable list. */
  with_stdout(sconcat(name,"_xor"),
    for cst in xor_csttl do block(
      [nb, m : if cstt_args_l(cst) = [] then 2 else cstt_args_l(cst)[1]],
      nb : floor(length(cst[2]) / (m+1)),
      for i : 1 thru nb do (
        print_nlb(
          sconcat("x ",
            lreduce(lambda([S,v],sconcat(S,v," ")),
              endcons(-cst[2][m*nb+i],
                create_list(cst[2][j*nb + i],j,0,m-1)),"")," 0")))))
)$


/* Takes a partial assignment, along with small scale parameters
   and returns true if the partial assignment represents a valid
   small scale encryption using those parameters. */
ss_validate(pa, r, ss_num_columns, ss_num_rows, ss_exp, final_round_b) :=
block([block_size],
  block_size : ss_num_columns * ss_num_rows * ss_exp,
  P : ss_pa2matrix(pa, create_list(i,i,1,block_size),
    2, ss_exp, ss_polynomial(2,ss_exp), ss_num_rows),
  K : ss_pa2matrix(pa, create_list(i,i,block_size+1,2*block_size),
    2, ss_exp, ss_polynomial(2,ss_exp), ss_num_rows),
  C : ss_pa2matrix(pa, create_list(i,i,2*block_size+1,3*block_size),
    2, ss_exp, ss_polynomial(2,ss_exp), ss_num_rows),
  return(
    is(ss_encrypt(P,K,r,2,ss_exp) = C))
)$


/******************************************************************
 * Testing cryptographic properties                               *
 ******************************************************************
*/

/* Outputs to file "name" a CNF which is satisfiable iff the AES cipher
   specified by input parameters has at least one key K and at least one
   plaintext P, such that the plaintext encrypted with K yields P. */
output_ss_fcl_id_p(name,r, ss_num_columns, ss_num_rows, ss_exp, final_round_b, box_tran, mc_tran) :=
  block([FF, FF_std,block_size : ss_num_columns * ss_num_rows * ss_exp],
    if oklib_monitor then print("Starting translation..."),
    FF : ss_fcl(r, ss_num_columns, ss_num_rows, ss_exp, final_round_b, box_tran, mc_tran),
    FF : [append(
            take_elements(2*block_size,FF[1]), /* Plaintext + Key */
            rest(FF[1], 3*block_size)), /* The rest of the variables */
          substitute_cl(FF[2],
            osm2hm(map("[",
                rest(take_elements(3*block_size,FF[1]),2*block_size),
                take_elements(block_size,FF[1]))))],
    if oklib_monitor then print("Starting standardisation..."),
    FF_std : standardise_fcl(FF),
    if oklib_monitor then print("Starting output..."),
    output_fcl_v(sconcat("Checking for key identical on single plaintext",
                   "for Small Scale AES with ",
                   "r=",r,",c=",ss_num_columns,",rw=",ss_num_rows,
                   ",e=",ss_exp,",final=",final_round_b,
                   ",box_tran=",box_tran,",mc_tran=",mc_tran),
                 FF_std[1],name,
      FF_std[2]))$  
output_ss_fcl_id_p_std(r, ss_num_columns, ss_num_rows, ss_exp, final_round_b, box_tran, mc_tran) :=
  output_ss_fcl_id_p(
    sconcat("ssaes_id_p_r", r, "_c",ss_num_columns, "_rw",ss_num_rows,"_e",
      ss_exp,"_f",if final_round_b then 1 else 0, ".cnf"),
    r, ss_num_columns, ss_num_rows, ss_exp, final_round_b, box_tran, mc_tran)$


/******************************************************************
 * Statistics                                                     *
 ******************************************************************
*/

/* Given the appropriate parameters, computes the number of sboxes
   in the associated small scale AES. The parameters are the number
   of rounds, and the number of columns and rows in the block. */
nsbox_ss(r,num_columns,num_rows) :=
  (r*num_columns*num_rows) + (r * num_rows)$

/* Given the appropriate parameters, computes the number of multiplications
   by the finite field element e (given as a polynomial) in the associated
   small scale AES. The parameters are the field element, given as a
   polynomial, number of rounds, and the number of columns, the small scale
   exponent, the mixcolumns matrix, whether or not to use a special final
   round (true/false) and the MixColumns translation to use (aes_mc_forward or
   aes_mc_bidirectional). */
nmul_ss_gen(e,r,num_cols,ss_exp,mixcolumns_matrix, final_round_b, mc_trans) :=
block([inv_mixcolumns_matrix, nmul, nmul_inv],
  inv_mixcolumns_matrix :
    ss_mixcolumns_matrix2inv_mixcolumns_matrix(2,ss_exp,mixcolumns_matrix),
  nmul : length(sublist(m2l_r(mixcolumns_matrix), lambda([a],is(a=e)))),
  if mc_trans = aes_mc_bidirectional then
    nmul_inv :
      length(sublist(m2l_r(inv_mixcolumns_matrix), lambda([a],is(a=e))))
  else nmul_inv : 0,
  if final_round_b then r : r -1,
  return(r * (nmul + nmul_inv) * num_cols))$
nmul_ss(e,r,num_cols, num_rows,ss_exp, final_round_b, mc_trans) :=
  nmul_ss_gen(e,r,num_cols,ss_exp,
    ss_mixcolumns_matrix(2,ss_exp,num_rows), final_round_b, mc_trans)$
/* Returns a set-map mapping field elements to the number of multiplications
   by those field elements in the AES translation specified by the arguments.
*/
nmul_ss_gen_sm(r,num_cols,ss_exp,mixcolumns_matrix, final_round_b, mc_trans) :=
block([inv_mixcolumns_matrix],
  inv_mixcolumns_matrix :
    ss_mixcolumns_matrix2inv_mixcolumns_matrix(2,ss_exp,mixcolumns_matrix),
  if final_round_b and r = 1 then []
  else setify(
    map(lambda([e],[e,
        nmul_ss_gen(e,r,num_cols,ss_exp,mixcolumns_matrix,
          final_round_b, mc_trans)]),
      append(m2l_r(mixcolumns_matrix),
        if mc_trans = aes_mc_bidirectional then m2l_r(inv_mixcolumns_matrix)
        else []))))$
nmul_ss_sm(r,num_cols,ss_exp, final_round_b, mc_trans) :=
  nmul_ss_gen_sm(r,num_cols,ss_exp,
    ss_mixcolumns_matrix(2, ss_exp, num_cols),final_round_b, mc_trans)$


/* Takes the number of rounds, number of columns, exponent of the field,
   the mixcolumns matrix, whether or not there is a special final round and
   which MixColumns translation to use and returns a set-map with elements
   of the form [n,m] where m is the number of boolean additions of arity n
   in the AES translation generated by ss_cstl with the provided input
   parameters.

   For example, a + b + c + d = e where a,b,c,d and e are boolean variables
   would be a boolean addition of arity four.

   Note that this function currently assumes that the MixColumns matrix,
   in the AES cipher specified by the parameters, doesn't contain a 0.
   This is the case for all currently used MixColumns matrices. */
nadd_ss_sm(r,num_cols, num_rows, ss_exp, final_round_b, mc_trans) :=
  block([m: if mc_trans = aes_mc_bidirectional then 2 else 1,
    r_w_mc : if final_round_b then r-1 else r,
    block_size : num_cols * num_rows * ss_exp],
  if num_rows = 2 and num_cols = 1 then
    {[2, block_size * (r+1) + ss_exp*r + (num_cols-1) * num_rows*ss_exp*r +
    num_rows*num_cols*r_w_mc*m*ss_exp]}
  else if num_rows = 3 and num_cols = 1 and final_round_b and r = 1 then
    {[2, block_size * (r+1) + ss_exp*r]}
  else if num_rows = 3 and num_cols = 1 then
    {[2, block_size * (r+1) + ss_exp*r], /* Round keys and key schedule */
     [3,num_rows*num_cols*r_w_mc*m*ss_exp]} /* MixColumns */
  else if num_rows = 2 then
    {[2, block_size * (r+1) + num_rows*num_cols*r_w_mc*m*ss_exp +
      ((num_cols-1) * num_rows + (num_rows-1))*ss_exp*r],
      /* Round keys, MixColumns and some of the key schedule */
    [3,ss_exp*r]} /* Key Schedule */
  else if num_rows = 3 then
      {[2, block_size * (r+1) +
       ((num_cols-1) * num_rows + (num_rows-1))*ss_exp*r],
       /* Round keys, and some of the key schedule */
      [3,r*ss_exp+num_rows*num_cols*r_w_mc*m*ss_exp]}
      /* Key Schedule and MixColumns */
  else if num_cols = 1 and final_round_b and r = 1 then
    {[2, block_size * (r+1) + ss_exp*r]}
  else if num_cols = 1 then
    {[2, block_size * (r+1) + ss_exp*r],
    [num_rows,num_rows*num_cols*r_w_mc*m*ss_exp]} /* MixColumns */
  else if final_round_b and r = 1 then
    {[2, (block_size) * (r+1) +
     ((num_cols-1) * num_rows + (num_rows-1))*ss_exp*r],
     /* Round Keys, and some of key schedule */
    [3,r*ss_exp]} /* Key Schedule*/
  else
    {[2, (block_size) * (r+1) +
     ((num_cols-1) * num_rows + (num_rows-1))*ss_exp*r],
    [3,r*ss_exp],
    [num_rows,num_rows*num_cols*r_w_mc*m*ss_exp]})$
nadd_ss(r,num_cols,num_rows,ss_exp, final_round_b, mc_trans) :=
  sum_l(listify(map(second,
      nadd_ss_sm(r,num_cols,num_rows,ss_exp, final_round_b, mc_trans))))$

/* Takes the number of rounds and returns the number of constants which appear
   as "ss_const" constraints in the AES translation. */
nconstants_ss(r) := r$


/* Given the appropriate parameters, computes the number of variables
   in the small scale AES clause-list translation.

   The parameters are the number of rounds, the number of columns, the small
   scale exponent, the mixcolumns matrix to use, the number of variables
   introduced by the sbox CNF translation, a list-map from the field elements
   in the mixcolumns to the number of variables introduced in the CNF
   translation of each multiplication, whether or not to use a special
   final round, and whether to include the MixColumns inversion or not
   (aes_mc_forward vs aes_mc_bidirectional). */
nvar_ss_gen(r,num_cols,num_rows,ss_exp,mixcolumns_matrix,
            num_sbox_vars,num_mul_vars_map,final_round_b,mc_trans) :=
block([mul_h : osm2hm(num_mul_vars_map), block_size],
  block_size : num_cols * num_rows * ss_exp,
  if final_round_b then
    return(
      (block_size * 3) + /* Input */
      (2 * r * block_size) + /* AES constraint (round keys + output) */
      ((r-1) * 2 * block_size) + /* Normal rounds */
      block_size + /* Normal rounds */
      (r * num_cols * num_rows * num_sbox_vars) + /* Subbytes - sboxes */
      sum_l(map(lambda([e],ev_hm_d(mul_h,e,0) +
            if e # 0 and e # 1 then ss_exp else 0),
          m2l_r(mixcolumns_matrix))) * num_cols * (r-1) +
      /* MixColumns - forward */
      (if mc_trans = aes_mc_bidirectional then
        sum_l(map(lambda([e],ev_hm_d(mul_h,e,0) +
              if e # 0 and e # 1 then ss_exp else 0),
            m2l_r(ss_mixcolumns_matrix2inv_mixcolumns_matrix(
                2,ss_exp,mixcolumns_matrix)))) else 0) * num_cols * (r-1) +
      /* MixColumns - inv */
      ((ss_exp * r) + (num_rows * r * (ss_exp + num_sbox_vars)))
      /* Key Schedule */)
  else
    return(
      (block_size * 3) + /* Input */
      (2 * r * block_size) + /* AES constraint (round keys + output) */
      (2 * r * block_size) + /* Normal rounds */
      (r * num_cols * num_rows * num_sbox_vars) + /* Subbytes - sboxes */
      sum_l(map(lambda([e],ev_hm_d(mul_h,e,0) +
            if e # 0 and e # 1 then ss_exp else 0),
          m2l_r(mixcolumns_matrix))) * num_cols * r +
      /* MixColumns - forward */
      (if mc_trans = aes_mc_bidirectional then
        sum_l(map(lambda([e],ev_hm_d(mul_h,e,0) +
              if e # 0 and e # 1 then ss_exp else 0),
            m2l_r(ss_mixcolumns_matrix2inv_mixcolumns_matrix(
                2,ss_exp,mixcolumns_matrix)))) else 0) * num_cols * r +
      /* MixColumns - inv */
      ((ss_exp * r) + (num_rows * r * (ss_exp + num_sbox_vars)))
      /* Key Schedule */))$
nvar_ss(r,num_cols,num_rows,ss_exp,final_round_b,box_tran,mc_trans) :=
  if box_tran = aes_small_box then
    nvar_ss_gen(r,num_cols,num_rows,ss_exp,
        ss_mixcolumns_matrix(2,ss_exp,num_rows),
        nvar_fcs(ev_hm(ss_sbox_cnfs,ss_exp))-(2*ss_exp),
        create_list(
          [nat2poly(e,2),
          nvar_fcs(ev_hm_d(ss_field_cnfs,[ss_exp,e],[{},{}]))-2*ss_exp],
          e,2,2^ss_exp-1),
        final_round_b, mc_trans)
  else if box_tran = aes_rbase_box then
    nvar_ss_gen(r,num_cols,num_rows,ss_exp,
        ss_mixcolumns_matrix(2,ss_exp,num_rows),
        nvar_list_fcs(ev_hm(ss_sbox_rbase_cnfs,ss_exp))-(2*ss_exp),
        create_list(
          [nat2poly(e,2),
           nvar_fcs(ev_hm_d(ss_field_rbase_cnfs,[ss_exp,e],[{},{}]))
             -(2*ss_exp)],
          e,2,2^ss_exp-1),
        final_round_b, mc_trans)
  else
    nvar_ss_gen(r,num_cols,num_rows,ss_exp,
        ss_mixcolumns_matrix(2,ss_exp,num_rows),
        nvar_full_dualts(2*ss_exp,2^ss_exp)-(2*ss_exp),
        create_list(
          [nat2poly(e,2), nvar_full_dualts(2*ss_exp,2^ss_exp)-(2*ss_exp)],
          e,2,2^ss_exp-1),
        final_round_b, mc_trans)$

/* Given the appropriate parameters, computes the number of clauses
   in the small scale AES clause-list translation.

   The parameters are the number of rounds, the number of columns, the small
   scale exponent, the mixcolumns matrix to use, the number of variables
   introduced by the sbox CNF translation, a list-map from the field elements
   in the mixcolumns to the number of variables introduced in the CNF
   translation of each multiplication, whether or not to use a special
   final round, and whether to include the MixColumns inversion or not
   (aes_mc_forward vs aes_mc_bidirectional). */
ncl_ss_gen(r,num_cols,num_rows,ss_exp,mixcolumns_matrix,
            num_sbox_cl,num_mul_cl_map,final_round_b,mc_trans) :=
block([mul_h : osm2hm(num_mul_cl_map), block_size],
  block_size : num_cols * num_rows * ss_exp,
  if final_round_b then
    return(
      4 * block_size * (r+1) + /* Addition constraints (binary) */
      (r * num_cols * num_rows * num_sbox_cl) + /* Subbytes - sboxes */
      sum_l(map(lambda([e],ev_hm_d(mul_h,e,0)),
          m2l_r(mixcolumns_matrix))) * num_cols * (r-1) +
      sum_l(map(lambda([R], 2^length(sublist(R,lambda([e],is(e#0))))),
        args(mixcolumns_matrix))) * ss_exp * num_cols * (r-1) +
      /* MixColumns - forward */
      (if mc_trans = aes_mc_bidirectional then
        sum_l(map(lambda([e],ev_hm_d(mul_h,e,0)),
            m2l_r(ss_mixcolumns_matrix2inv_mixcolumns_matrix(
                2,ss_exp,mixcolumns_matrix)))) else 0) * num_cols * (r-1) +
      (if mc_trans = aes_mc_bidirectional then
        sum_l(map(lambda([R], 2^length(sublist(R,lambda([e],is(e#0))))),
          args(ss_mixcolumns_matrix2inv_mixcolumns_matrix(
                2,ss_exp,mixcolumns_matrix)))) else 0) * ss_exp * num_cols * (r-1) +
      /* MixColumns - inv */
      ((ss_exp * r) + (num_rows * r * num_sbox_cl)) +
      if num_cols > 1 then
        ((num_rows * (num_cols-1) * 4) + ((num_rows-1) * 4) + 8) * ss_exp * r
      else
        ((num_cols-1) * num_rows + 1) * 4 * ss_exp * r
      /* Key Schedule */)
  else
    return(
      4 * block_size * (r+1) + /* Addition constraints (binary) */
      (r * num_cols * num_rows * num_sbox_cl) + /* Subbytes - sboxes */
      sum_l(map(lambda([e],ev_hm_d(mul_h,e,0)),
          m2l_r(mixcolumns_matrix))) * num_cols * r +
      sum_l(map(lambda([R], 2^length(sublist(R,lambda([e],is(e#0))))),
        args(mixcolumns_matrix))) * ss_exp * num_cols * r +
      /* MixColumns - forward */
      (if mc_trans = aes_mc_bidirectional then
        sum_l(map(lambda([e],ev_hm_d(mul_h,e,0)),
            m2l_r(ss_mixcolumns_matrix2inv_mixcolumns_matrix(
                2,ss_exp,mixcolumns_matrix)))) else 0) * num_cols * r +
      (if mc_trans = aes_mc_bidirectional then
        sum_l(map(lambda([R], 2^length(sublist(R,lambda([e],is(e#0))))),
          args(ss_mixcolumns_matrix2inv_mixcolumns_matrix(
                2,ss_exp,mixcolumns_matrix)))) else 0) * ss_exp * num_cols * r +
      /* MixColumns - inv */
      ((ss_exp * r) + (num_rows * r * num_sbox_cl)) +
      if num_cols > 1 then
        ((num_rows * (num_cols-1) * 4) + ((num_rows-1) * 4) + 8) * ss_exp * r
      else
        ((num_cols-1) * num_rows + 1) * 4 * ss_exp * r
      /* Key Schedule */))$
ncl_ss(r,num_cols,num_rows,ss_exp,final_round_b,box_tran,mc_trans) :=
  if box_tran = aes_small_box then
    ncl_ss_gen(r,num_cols,num_rows,ss_exp,
        ss_mixcolumns_matrix(2,ss_exp,num_rows),
        ncl_fcs(ev_hm(ss_sbox_cnfs,ss_exp)),
        create_list(
          [nat2poly(e,2), ncl_fcs(ev_hm_d(ss_field_cnfs,[ss_exp,e],[{},{}]))],
          e,2,2^ss_exp-1),
        final_round_b, mc_trans)
  else if box_tran = aes_rbase_box then
    ncl_ss_gen(r,num_cols,num_rows,ss_exp,
        ss_mixcolumns_matrix(2,ss_exp,num_rows),
        ncl_list_fcs(ev_hm(ss_sbox_rbase_cnfs,ss_exp)),
        create_list(
          [nat2poly(e,2),
          ncl_fcs(ev_hm_d(ss_field_rbase_cnfs,[ss_exp,e],[{},{}]))],
          e,2,2^ss_exp-1),
        final_round_b, mc_trans)
  else
    ncl_ss_gen(r,num_cols,num_rows,ss_exp,
        ss_mixcolumns_matrix(2,ss_exp,num_rows),
        ncl_full_dualts(2*ss_exp,2^ss_exp),
        create_list(
          [nat2poly(e,2), ncl_full_dualts(2*ss_exp,2^ss_exp)],
          e,2,2^ss_exp-1),
        final_round_b, mc_trans)$

/* Given the appropriate parameters, computes the number of clauses
   of each length in the small scale AES clause-list translation, returning
   the result as a list of pairs with the first element of each pair
   being the size of the clause, and the second being the number of clauses
   of that size in the translation.

   The parameters are the number of rounds, the number of columns, the number
   of rows, the small scale exponent, the mixcolumns matrix to use, the number
   of variables introduced by the sbox CNF translation, a list-map from the
   field elements in the MixColumns to the number of variables introduced in
   the CNF translation of each multiplication, whether or not to use a special
   final round, and whether to include the MixColumns inversion or not
   (aes_mc_forward vs aes_mc_bidirectional). */
ncl_list_ss_gen(r,num_cols,num_rows,ss_exp,mixcolumns_matrix,
            ncl_list_sbox,ncl_list_mul_map,final_round_b,mc_trans) :=
block([ncl_list_mul_h : sm2hm(ncl_list_mul_map)],
multi_list_distribution2list_distribution(
  append(
    map(lambda([a],[a[1],nsbox_ss(r,num_cols,num_rows) * a[2]]),
        ncl_list_sbox),
    lappend(map(lambda([e],
          map(lambda([a], [a[1],a[2]*e[2]]),
            ev_hm_d(ncl_list_mul_h,e[1],[]))),
        listify(nmul_ss_gen_sm(r,num_cols,ss_exp,mixcolumns_matrix,
            final_round_b,mc_trans)))),
    [[1, nconstants_ss(r)*ss_exp]],
    map(lambda([P], [P[1]+1,2^(P[1]) * P[2]]),
      listify(nadd_ss_sm(r,num_cols,num_rows,ss_exp,final_round_b,mc_trans)))
    )))$
ncl_list_ss(r,num_cols,num_rows,ss_exp,final_round_b,box_tran,mc_trans) :=
block([mixcolumns_matrix : ss_mixcolumns_matrix(2,ss_exp,num_rows),
       inv_mixcolumns_matrix, mixcolumns_mult_l],
  inv_mixcolumns_matrix :
    ss_mixcolumns_matrix2inv_mixcolumns_matrix(2,ss_exp,mixcolumns_matrix),
  mixcolumns_mult_l :
    unique(append(m2l_r(mixcolumns_matrix),m2l_r(inv_mixcolumns_matrix))),
  mixcolumns_mult_l :
    sublist(mixcolumns_mult_l, lambda([a], is(a # 1) and is(a # 0))),
  if box_tran = aes_small_box then
    ncl_list_ss_gen(r,num_cols,num_rows,ss_exp,
        ss_mixcolumns_matrix(2,ss_exp,num_rows),
        ncl_list_fcs(ev_hm(ss_sbox_cnfs,ss_exp)),
        create_list(
          [e, ncl_list_fcs(
            ev_hm(ss_field_cnfs,[ss_exp,poly2nat(e,2)]))],
          e, mixcolumns_mult_l),
        final_round_b, mc_trans)
  else if box_tran = aes_rbase_box then
      ncl_list_ss_gen(r,num_cols,num_rows,ss_exp,
        ss_mixcolumns_matrix(2,ss_exp,num_rows),
        ncl_list_fcs(ev_hm(ss_sbox_rbase_cnfs,ss_exp)),
        create_list(
          [e, ncl_list_fcs(
            ev_hm(ss_field_rbase_cnfs,[ss_exp,poly2nat(e,2)]))],
          e, mixcolumns_mult_l),
        final_round_b, mc_trans)
  else
      ncl_list_ss_gen(r,num_cols,num_rows,ss_exp,
        ss_mixcolumns_matrix(2,ss_exp,num_rows),
        ncl_list_full_dualts(2*ss_exp,2^ss_exp),
        create_list(
          [e, ncl_list_full_dualts(2*ss_exp,2^ss_exp)],
          e, mixcolumns_mult_l),
        final_round_b, mc_trans))$


/* Given the appropriate parameters returns basic statistics on
   the number of each component in the AES translation specified
   by the parameters.

   The result is of the form:

   [full_r,special_r,#round_sbox,#round_add,#mc_l,#ks_sbox,#ks_add,#ks_const]

   where:
      full_r       is the number of full rounds including MixColumns
      special_r    is the number of final rounds excluding MixColumns (0/1)
      #round_sbox  is the number of Sboxes occurring in the round components
      #round_add   is the number of round additions
      #mc_l        is a list of pairs mapping field elements to the number
                   of multiplications by those field elements that occur
                   in the translation (in the MixColumns operation)
      #ks_sbox     is the number of Sboxes occurring in the AES key expansion
      #ks_add      is the number of additions occurring in the AES key
                   expansion
      #ks_const    is the number of constant additions in the AES key
                   expansion

   The parameters are the number of rounds, the number of columns, the number
   of rows, the small scale exponent, the mixcolumns matrix to use, whether or
   not to use a special final round, and whether to include the MixColumns
   inversion or not (aes_mc_forward vs aes_mc_bidirectional). */
component_statistics_ss_gen(r,num_cols,num_rows,ss_exp,mixcolumns_matrix,
  final_round_b,mc_trans) :=
block([mc_r : if final_round_b then r-1 else r,
       mc_c : if mc_trans = aes_mc_bidirectional then 2 else 1],
  [
    mc_r,
    if final_round_b then 1 else 0,
    r * num_cols * num_rows,
    ss_exp*num_cols*num_rows*(r+1) + num_rows*num_cols*ss_exp*mc_r*mc_c,
    listify(nmul_ss_gen_sm(r,num_cols,ss_exp,mixcolumns_matrix,
      final_round_b, mc_trans)),
    num_rows * r,
    (if num_cols = 1 then 1 else num_rows) * ss_exp * r +
      (num_cols-1) * num_rows*ss_exp*r,
    ss_exp * r])$
component_statistics_ss(r,num_cols,num_rows,ss_exp,final_round_b,mc_trans) :=
  component_statistics_ss_gen(r,num_cols,num_rows,ss_exp,
    ss_mixcolumns_matrix(2,ss_exp,num_rows),final_round_b,mc_trans)$


/******************************************************************
 * Data translation                                               *
 ******************************************************************
*/

/* AES data translation */

/* TODO: Move such constants to constants (i.e. AES row size, column size etc). */

output_aes_random_pc_pair(seed, num_rounds) :=
 /* Constants: AES uses the GF(2^8) field and has 4 columns and 4 rows.  */
 output_ss_random_pc_pair(seed, 2,8, ss_polynomial_2_8, 4, 4, num_rounds)$


/* Takes a hexidecimal string in the notation typically used for Rijndael blocks
   (discussed in [Design of Rijndael] and in CryptoSystems plans) and given the
   variable list (assumed to be in the correct left to right bit ordering)
   generates a PA to the given variables to the given constant.  */
aes_hex2pa(hexStr, variableList) := block(
  setify(map(
    lambda([a,b], if b = 0 then -a else a),
        variableList, 
        lappend(map(lambda([a], 
          egf_coeffs(rijn_bit_field,a,7)),hex2gf2t8l(hexStr)))
  ))
)$

/* Small scale data translation */

ss_random_matrix(b,e,mod_poly, num_rows, num_cols) :=
    genmatrix(lambda([x,y], ss_stand(nat2poly(random(b^e),b),b,mod_poly)),
      num_rows, num_cols)$

ss_matrix2pa(m,var_list,b,e,mod_poly) := block([nl, bits],
  nl : ss_m2natl(m,b),
  bits : lappend(map(lambda([a],int2polyadic_padd(a,b,e)), nl)),
  return(
    map(lambda([bit_,var_], if bit_ > 0 then var_ else -var_), bits,var_list))
  )$

/* Assumes all of var_list occur as vars in lit_set in some form */
ss_pa2matrix(lit_set, var_list,b,e,mod_poly, num_rows) := block([nl, bits],
  bits : map(lambda([a], if member(a,lit_set) then 1 else 0), var_list),
  nl : map(lambda([a], polyadic2int(a,b)),partition_elements(bits,e)),
  return(ss_natl2m(nl,b,num_rows)))$

ss_pa2matrix_std(lit_set, e,num_rows, num_cols) :=
  ss_pa2matrix(lit_set,
    create_list(i,i,e*num_rows*num_cols+1,2*e*num_rows*num_cols),
    2,e,ss_polynomial(2,e),num_rows)$

/* Outputs random plaintext, ciphertext pair as a clause-set with
   the associated unit-clauses, given the small scale parameters. */
output_ss_random_pc_pair(seed, num_rounds, num_cols, num_rows,ss_exp, final_round_b) :=
  block(
    [s, plaintext, key, ciphertext, comment, filename, plaintext_vars,
     ciphertext_vars, pc_phi, pc_unit_fcs, b : 2,
     mod_poly : ss_polynomial(2,ss_exp)],
    s : make_random_state(seed),
    set_random_state(s),
    plaintext : ss_random_matrix(b,ss_exp,mod_poly,num_rows,num_cols),
    key : ss_random_matrix(b,ss_exp,mod_poly,num_rows, num_cols),
    if final_round_b then
      ciphertext : ss_encrypt_wf(plaintext, key, num_rounds, b,ss_exp)
    else
      ciphertext : ss_encrypt(plaintext, key, num_rounds, b,ss_exp),
    comment : sconcat(
      "S : ", seed, " ",
      "P : ", ss_matrix2hex(plaintext, b,ss_exp,mod_poly), " ",
      "K : ", ss_matrix2hex(key, b,ss_exp,mod_poly)," ",
      "C : ", ss_matrix2hex(ciphertext, b,ss_exp,mod_poly), " ",
      "A : ", [b,ss_exp,mod_poly,num_rows,num_cols, num_rounds]),
    filename : sconcat(
      "ssaes_pcpair_r", num_rounds , "_c", num_cols, "_rw", num_rows, "_e",
      ss_exp,"_f", if final_round_b then 1 else 0,"_",box_tran, "_", mc_tran,
      "_s", seed, ".cnf"),
    plaintext_vars : create_list(i,i,1, ss_exp * num_rows * num_cols),
    ciphertext_vars : create_list(i,i,
      2*ss_exp * num_rows * num_cols+1, 3*ss_exp * num_rows * num_cols),
    pc_phi : append(
      ss_matrix2pa(plaintext, plaintext_vars, b, ss_exp, mod_poly),
      ss_matrix2pa(ciphertext, ciphertext_vars, b, ss_exp, mod_poly)),
    pc_unit_fcs : [setify(create_list(i,i,1, 3*ss_exp * num_rows * num_cols)),
                   setify(map(set, pc_phi))],
    output_fcs(comment, pc_unit_fcs, filename))$
output_ss_random_pk_pair(seed, num_rounds, num_cols, num_rows,ss_exp, final_round_b) :=
  block(
    [s, plaintext, key, ciphertext, comment, filename, plaintext_vars,
     ciphertext_vars, pc_phi, pc_unit_fcs, b : 2,
     mod_poly : ss_polynomial(2,ss_exp)],
    s : make_random_state(seed),
    set_random_state(s),
    plaintext : ss_random_matrix(b,ss_exp,mod_poly,num_rows,num_cols),
    key : ss_random_matrix(b,ss_exp,mod_poly,num_rows, num_cols),
    if final_round_b then
      ciphertext : ss_encrypt_wf(plaintext, key, num_rounds, b,ss_exp)
    else
      ciphertext : ss_encrypt(plaintext, key, num_rounds, b,ss_exp),
    comment : sconcat(
      "S : ", seed, " ",
      "P : ", ss_matrix2hex(plaintext, b,ss_exp,mod_poly), " ",
      "K : ", ss_matrix2hex(key, b,ss_exp,mod_poly)," ",
      "C : ", ss_matrix2hex(ciphertext, b,ss_exp,mod_poly), " ",
      "A : ", [b,ss_exp,mod_poly,num_rows,num_cols, num_rounds]),
    filename : sconcat(
      "ssaes_pkpair_r", num_rounds , "_c", num_cols, "_rw", num_rows, "_e",
      ss_exp,"_f", if final_round_b then 1 else 0,"_s", seed, ".cnf"),
    plaintext_vars : create_list(i,i,1, ss_exp * num_rows * num_cols),
    key_vars : create_list(i,i,
      ss_exp * num_rows * num_cols+1, 2*ss_exp * num_rows * num_cols),
    pc_phi : append(
      ss_matrix2pa(plaintext, plaintext_vars, b, ss_exp, mod_poly),
      ss_matrix2pa(key, key_vars, b, ss_exp, mod_poly)),
    pc_unit_fcs : [setify(create_list(i,i,1, 3*ss_exp * num_rows * num_cols)),
                   setify(map(set, pc_phi))],
    output_fcs(comment, pc_unit_fcs, filename))$
output_ss_random_kc_pair(seed, num_rounds, num_cols, num_rows,ss_exp, final_round_b) :=
  block(
    [s, plaintext, key, ciphertext, comment, filename, plaintext_vars,
     ciphertext_vars, pc_phi, pc_unit_fcs, b : 2,
     mod_poly : ss_polynomial(2,ss_exp)],
    s : make_random_state(seed),
    set_random_state(s),
    plaintext : ss_random_matrix(b,ss_exp,mod_poly,num_rows,num_cols),
    key : ss_random_matrix(b,ss_exp,mod_poly,num_rows, num_cols),
    if final_round_b then
      ciphertext : ss_encrypt_wf(plaintext, key, num_rounds, b,ss_exp)
    else
      ciphertext : ss_encrypt(plaintext, key, num_rounds, b,ss_exp),
    comment : sconcat(
      "S : ", seed, " ",
      "P : ", ss_matrix2hex(plaintext, b,ss_exp,mod_poly), " ",
      "K : ", ss_matrix2hex(key, b,ss_exp,mod_poly)," ",
      "C : ", ss_matrix2hex(ciphertext, b,ss_exp,mod_poly), " ",
      "A : ", [b,ss_exp,mod_poly,num_rows,num_cols, num_rounds]),
    filename : sconcat(
      "ssaes_kcpair_r", num_rounds , "_c", num_cols, "_rw", num_rows, "_e",
      ss_exp,"_f", if final_round_b then 1 else 0,"_s", seed, ".cnf"),
    ciphertext_vars : create_list(i,i,
      2*ss_exp * num_rows * num_cols+1, 3*ss_exp * num_rows * num_cols),
    key_vars : create_list(i,i,
      ss_exp * num_rows * num_cols+1, 2*ss_exp * num_rows * num_cols),
    pc_phi : append(
      ss_matrix2pa(plaintext, key_vars, b, ss_exp, mod_poly),
      ss_matrix2pa(key, ciphertext_vars, b, ss_exp, mod_poly)),
    pc_unit_fcs : [setify(create_list(i,i,1, 3*ss_exp * num_rows * num_cols)),
                   setify(map(set, pc_phi))],
    output_fcs(comment, pc_unit_fcs, filename))$


/******************************************************************************
 * Global propagation                                                         *
 ******************************************************************************
*/

aes_propagations : [prop_eq_csttl]$
ss_propagations : [prop_eq_csttl]$


/******************************************************************************
 * CNF translations                                                           *
 ******************************************************************************
*/

/* AES */

/* Translation mapping, mapping constraint templates to the corresponding
   translation functions where constraints are translated to CNF clause-set
   representations using subsets of the prime implicates: */
aes_pi_translation_mapping : [
  ["aes_add_cst", [aes_add_cst_cl, lambda([[a]],[])]],
  ["const_cst", [aes_const_cst_cl, lambda([[a]],[])]],
  ["aes_mul2_cst", [aes_mul2_pi_cst_cl, lambda([[a]],[])]],
  ["aes_mul3_cst", [aes_mul3_pi_cst_cl, lambda([[a]],[])]],
  ["aes_mul14_cst", [aes_mul14_pi_cst_cl, lambda([[a]],[])]],
  ["aes_mul13_cst", [aes_mul13_pi_cst_cl, lambda([[a]],[])]],
  ["aes_mul11_cst", [aes_mul11_pi_cst_cl, lambda([[a]],[])]],
  ["aes_mul9_cst", [aes_mul9_pi_cst_cl, lambda([[a]],[])]],
  ["aes_sbox_cst", [aes_sbox_pi_cst_cl, lambda([[a]],[])]]]$

/* Translation mapping, mapping constraint templates to the corresponding
   translation functions where constraints are translated to representations
   using subsets of the prime implicates: */
aes_ts_translation_mapping : [
  ["aes_add_cst", [aes_add_cst_cl, lambda([[a]],[])]],
  ["const_cst", [aes_const_cst_cl, lambda([[a]],[])]],
  ["aes_mul2_cst", [aes_mul2_ts_cst_cl, aes_mul2_ts_var_l]],
  ["aes_mul3_cst", [aes_mul3_ts_cst_cl, aes_mul3_ts_var_l]],
  ["aes_mul14_cst", [aes_mul14_ts_cst_cl, aes_mul14_ts_var_l]],
  ["aes_mul13_cst", [aes_mul13_ts_cst_cl, aes_mul13_ts_var_l]],
  ["aes_mul11_cst", [aes_mul11_ts_cst_cl, aes_mul11_ts_var_l]],
  ["aes_mul9_cst", [aes_mul9_ts_cst_cl, aes_mul9_ts_var_l]],
  ["aes_sbox_cst", [aes_sbox_ts_cst_cl, aes_sbox_ts_var_l]]]$

/* Small Scale */

/* Translation mapping, mapping constraint templates to the corresponding
   translation functions where constraints are translated to CNF clause-set
   representations using subsets of the prime implicates: */
ss_pi_translation_mapping : [
  ["ss_add_cst", [aes_add_cst_cl, lambda([[a]],[])]],
  ["const_cst", [aes_const_cst_cl, lambda([[a]],[])]],
  ["ss_mul_cst", [ss_mul_pi_cst_cl, lambda([[a]],[])]],
  ["ss_sbox_w_mul_cst", [ss_sbox_w_mul_pi_cst_cl, lambda([[a]],[])]],
  ["ss_sbox_cst", [ss_sbox_pi_cst_cl, lambda([[a]],[])]],
  ["ss_round_column_cst",
    [ss_round_column_pi_cst_cl, lambda([a],[])]]]$

/* Translation mapping, mapping constraint templates to the corresponding
   translation functions where constraints are translated to CNF clause-set
   representations using r_1 bases: */
ss_rbase_translation_mapping : [
  ["ss_add_cst", [aes_add_cst_cl, lambda([[a]],[])]],
  ["const_cst", [aes_const_cst_cl, lambda([[a]],[])]],
  ["ss_mul_cst", [ss_mul_rbase_cst_cl, lambda([[a]],[])]],
  ["ss_sbox_w_mul_cst", [ss_sbox_w_mul_rbase_cst_cl, lambda([[a]],[])]],
  ["ss_sbox_cst", [ss_sbox_rbase_cst_cl, lambda([[a]],[])]],
  ["ss_round_column_cst",
    [ss_round_column_rbase_cst_cl, lambda([a],[])]]]$

/* Translation mapping, mapping constraint templates to the corresponding
   translation functions where constraints are translated to representations
   using the canonical translation: */
ss_ts_translation_mapping : [
  ["ss_add_cst", [aes_add_cst_cl, lambda([[a]],[])]],
  ["const_cst", [aes_const_cst_cl, lambda([[a]],[])]],
  ["ss_mul_cst", [ss_mul_ts_cst_cl, ss_mul_ts_var_l]],
  ["ss_sbox_cst", [ss_sbox_ts_cst_cl, ss_sbox_ts_var_l]],
  ["ss_sbox_w_mul_cst", [ss_sbox_w_mul_ts_cst_cl, ss_sbox_w_mul_ts_var_l]],
  ["ss_round_column_cst",
    [ss_round_column_ts_cst_cl, ss_round_column_ts_var_l]],
  ["ss_mixcolumn_cst", [ss_mixcolumn_ts_cst_cl, ss_mixcolumn_ts_var_l]]]$

/* Translation mapping, mapping constraint templates to the corresponding
   translation functions where constraints are translated to representations
   using the canonical CNF: */
ss_full_translation_mapping : [
  ["ss_add_cst", [aes_add_cst_cl, lambda([[a]],[])]],
  ["const_cst", [aes_const_cst_cl, lambda([[a]],[])]],
  ["ss_mul_cst", [ss_mul_full_cst_cl, lambda([[a]],[])]],
  ["ss_sbox_cst", [ss_sbox_full_cst_cl, lambda([[a]],[])]],
  ["ss_sbox_w_mul_cst", [ss_sbox_w_mul_full_cst_cl, lambda([[a]],[])]],
  ["ss_round_column_cst",
    [ss_round_column_full_cst_cl, lambda([[a]],[])]],
  ["ss_mixcolumn_cst", [ss_mixcolumn_full_cst_cl, lambda([[a]],[])]]]$

/*!
\endhtmlonly
*/
