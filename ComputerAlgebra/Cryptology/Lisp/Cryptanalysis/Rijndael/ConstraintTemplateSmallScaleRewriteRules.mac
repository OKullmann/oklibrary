/* Matthew Gwynne, 28.9.2010 (Swansea) */
/* Copyright 2010, 2011 Oliver Kullmann
This file is part of the OKlibrary. OKlibrary is free software; you can redistribute
it and/or modify it under the terms of the GNU General Public License as published by
the Free Software Foundation and included in this library; either version 3 of the
License, or any later version. */

/*!
  \file ComputerAlgebra/Cryptology/Lisp/Cryptanalysis/Rijndael/ConstraintTemplateSmallScaleRewriteRules.mac
  \brief Functions for translating small-scale AES constraint templates into further AES constraint templates and CNF representations.

  Functions are defined here for the translation of constraints for components
  of the small scale AES block cipher.

  The functions provided are to be used with the general translation
  mechanisms given in
  ComputerAlgebra/Cryptology/Lisp/Cryptanalysis/Rijndael/ConstraintTemplateRewriteSystem.mac
  and
  ComputerAlgebra/Cryptology/Lisp/Cryptanalysis/Rijndael/ConstraintTemplateTranslation.mac.
  The notions of constraint templates, rewrite bundles and so on, are
  explained in each of these files.

Use by

oklib_load("OKlib/ComputerAlgebra/Cryptology/Lisp/Cryptanalysis/Rijndael/ConstraintTemplateSmallScaleRewriteRules.mac");

  
*/

/*!
\htmlonly
*/


oklib_include("OKlib/ComputerAlgebra/Cryptology/Lisp/Cryptanalysis/Rijndael/ConstraintTemplateRewriteSystem.mac");
oklib_include("OKlib/ComputerAlgebra/DataStructures/Lisp/Lists.mac")$
oklib_include("OKlib/ComputerAlgebra/Satisfiability/Lisp/FiniteFunctions/Permutations.mac")$
oklib_include("OKlib/ComputerAlgebra/Satisfiability/Lisp/Generators/Generators.mac")$
oklib_include("OKlib/ComputerAlgebra/Cryptology/Lisp/Cryptanalysis/Rijndael/data/SmallScaleFieldMulCNF.mac")$
oklib_include("OKlib/ComputerAlgebra/Cryptology/Lisp/Cryptanalysis/Rijndael/data/SmallScaleSboxCNF.mac")$



/* ***********************************************
   * Constraint template rewrite translations    *
   ***********************************************
*/

/* Small scale AES variables, ss_v(i,id), for i in NN where id is an
   identifier used to allow specialisation:  */
kill(ss_v)$
declare(ss_v, noun)$
declare(ss_v, posfun)$
ss_var(i,id) := nounify(ss_v)(i,id)$
/* For example, ss_v(1,o) is the first output bit.

   Note that these variables are then later wrapped in namespaces. */

/* Given two integers n and m, a namespace, and
   a noun identifier, returns a list of AES variables of the form
   namespace(ss_v(i,id)) for n <= i <= m. */
generate_ss_constraint_vars(n,m,namespace, id) :=
  create_list(namespace(ss_var(i,id)),i,n,m)$

/* Rewrite maps */

/* Standard rewrite mapping: */
ss_rewrite_mapping_std :
  [["ss_cst",ss_cstrb],["ss_key_expansion_cst",ss_key_expansion_cstrb],
  ["ss_round_cst",ss_round_cstrb],
  ["ss_final_round_cst",ss_final_round_cstrb],
  ["ss_subbytes_cst",ss_subbytes_cstrb],
  ["ss_shiftrows_cst",ss_shiftrows_cstrb],
  ["ss_mixcolumns_cst",ss_mixcolumns_cstrb],
  ["ss_mixcolumn_cst",ss_mixcolumn_cstrb]]$

/* Rewrite mapping introducing both forward and backward
   MixColumns translations: */
ss_bimc_rewrite_mapping_std :
  [["ss_cst",ss_cstrb],["ss_key_expansion_cst",ss_key_expansion_cstrb],
  ["ss_round_cst",ss_round_cstrb],
  ["ss_final_round_cst",ss_final_round_cstrb],
  ["ss_subbytes_cst",ss_subbytes_cstrb],
  ["ss_shiftrows_cst",ss_shiftrows_cstrb],
  ["ss_mixcolumns_cst",ss_mixcolumns_cstrb],
  ["ss_mixcolumn_cst",ss_bi_mixcolumn_cstrb]]$

/* Rewrite mapping translating the MixColumns operation as a boolean
   matrix multiplication (using addition constraints): */
ss_boolm_rewrite_mapping_std :
  [["ss_cst",ss_cstrb],["ss_key_expansion_cst",ss_key_expansion_cstrb],
  ["ss_round_cst",ss_round_cstrb],
  ["ss_final_round_cst",ss_final_round_cstrb],
  ["ss_subbytes_cst",ss_subbytes_cstrb],
  ["ss_shiftrows_cst",ss_shiftrows_cstrb],
  ["ss_mixcolumns_cst",ss_mixcolumns_cstrb],
  ["ss_mixcolumn_cst",ss_mixcolumn_boolm_cstrb]]$

/* Rewrite mapping translating the MixColumns operation using
   the canonical translation: */
ss_boxmc_rewrite_mapping_std :
  [["ss_cst",ss_cstrb],["ss_key_expansion_cst",ss_key_expansion_cstrb],
  ["ss_round_cst",ss_round_cstrb],
  ["ss_final_round_cst",ss_final_round_cstrb],
  ["ss_subbytes_cst",ss_subbytes_cstrb],
  ["ss_shiftrows_cst",ss_shiftrows_cstrb],
  ["ss_mixcolumns_cst",ss_mixcolumns_cstrb]]$
/* Note that the MixColumns is left unspecified and
   the user must specify use the "ss_ts_translation_mapping" translation
   mapping which will then translate all constraints remaining after the
   constraint rewrite stage, using the canonical translation, including
   the MixColumn.

   In all other rewrite maps, the MixColumn is translated during the
   rewrite stage and therefore, even if one uses "ss_ts_translation_mapping",
   there are no "ss_mixcolumn_cst" constraints to be translated using the
   canonical translation, only the multiplications etc which the MixColumns
   was rewritten to.
*/


/* ***********************************************
   * Constraint template rewrite functions       *
   ***********************************************
*/

/* Small scale AES constraint rewrite bundle: */
ss_cstrb : [ss_cstr_cstl,ss_namespace,ss_ns_var_l]$

/* Small scale AES namespace: */
kill(ss_ctr_ns)$
declare(ss_ctr_ns,noun)$
declare(ss_ctr_ns,posfun)$
ss_namespace([args]) := apply(nounify(ss_ctr_ns),args)$


/* The list of new variables introduced by ss_cstr_cstl
   with the constraint template cst as input: */
ss_ns_var_l(cst) := block(
  [ss_num_rounds,vars : [],namespace, ss_args_l,
  ss_num_columns, ss_num_rows, ss_base, ss_exp,
  num_block_bits],
  namespace : cstt_namespace_new (ss_namespace,cst),
  ss_arg_l : cstt_args_l(cst),
  ss_num_rounds : ss_arg_l[1],
  ss_num_columns : ss_arg_l[2],
  ss_num_rows : ss_arg_l[3],
  ss_base : ss_arg_l[4],
  ss_exp : ss_arg_l[5],
  num_block_bits : ss_num_columns * ss_num_rows * ss_exp,
  vars : cons(
    generate_ss_constraint_vars(1,(ss_num_rounds+1)*num_block_bits,
      namespace,nounify(k)),vars),
  vars : cons(
    generate_ss_constraint_vars(1,ss_num_rounds*num_block_bits,
      namespace,nounify(o)),vars),
  return(lappend(vars)))$

/* TODO: Rewrite documentation below. */

/* Rewrite function designed to rewrite the AES constraint template "ss_ct".

   Takes as arguments 385 variables, which are the arguments of the "aes_ct"
   instance being rewritten.

   The first 384 of these are 128 plaintext, 128 key and 128 ciphertext
   variables respectively. The final argument is a pair (list) of auxiliary
   arguments, the first being the namespace to place all variables introduced
   by this function within, and the second being the integer number of rounds
   which specifies which round-variant of AES is being rewritten.

   The result of this function is a list of constraint template instances
   representing the AES constraint template instance being rewritten.
*/
ss_cstr_cstl(cst) := block(
  [bits, pBits, kBits, cBits, ekBits, ib, ob, rs : [],namespace,
  ss_num_rounds, ss_num_columns, ss_num_rows, ss_base, ss_exp, ss_poly,
  ss_sbox_matrix, ss_affine_constant, ss_mixcolumns_matrix, ss_arg_l,
  final_round_b,num_block_bits ],
  ss_arg_l : cstt_args_l(cst),
  ss_num_rounds : ss_arg_l[1],
  ss_num_columns : ss_arg_l[2],
  ss_num_rows : ss_arg_l[3],
  ss_base : ss_arg_l[4],
  ss_exp : ss_arg_l[5],
  ss_poly : ss_arg_l[6],
  ss_sbox_matrix : ss_arg_l[7],
  ss_affine_constant : ss_arg_l[8],
  ss_mixcolumns_matrix : ss_arg_l[9],
  final_round_b : ss_arg_l[10],
  num_block_bits : ss_num_columns * ss_num_rows * ss_exp,
  bits : cst[2],
  namespace : cstt_namespace_new(ss_namespace,cst),
  pBits : take_elements(num_block_bits,bits),
  kBits : take_elements(num_block_bits,rest(bits,num_block_bits)),
  cBits : rest(bits,num_block_bits*2),
  ekBits :
    generate_ss_constraint_vars(
      1,(ss_num_rounds+1)*num_block_bits,namespace,nounify(k)),
  /* Key Expansion */
  rs : cons(
    cstt_new(
      "ss_key_expansion_cst",append(kBits,ekBits),
      [ss_num_rounds, ss_num_columns, ss_num_rows, ss_base, ss_exp,
       ss_poly, ss_sbox_matrix, ss_affine_constant],namespace),
    rs),
  ib : pBits,
  all_ob :
    generate_ss_constraint_vars(1,(ss_num_rounds)*num_block_bits,
      namespace,nounify(o)),
  ob : take_elements(num_block_bits,all_ob),
  /* Initial Round Key Addition */
  rs : cons(
    cstt_new(
      "ss_add_cst",append(ib,take_elements(num_block_bits,ekBits),ob),
      [], namespace),
    rs),
  ib : ob,
  /* Rounds */
  for j : 1 thru (ss_num_rounds - 1) do block(
    ob : take_elements(num_block_bits,rest(all_ob,j*num_block_bits)),
    rs : cons(
      cstt_new("ss_round_cst",
        append(ib,take_elements(num_block_bits,rest(ekBits,j*num_block_bits)),
          ob),
        [j, ss_num_columns, ss_num_rows, ss_base, ss_exp,
       ss_poly, ss_sbox_matrix, ss_affine_constant, ss_mixcolumns_matrix],
       namespace),rs),
    ib : ob
  ),
  /* Final Round */
  /* If we have a reduced round variant, truncate rather than generalise */
  ob : cBits,
  if final_round_b then 
    rs : cons(
      cstt_new("ss_final_round_cst",
        append(ib,take_elements(num_block_bits,
            rest(ekBits,ss_num_rounds*num_block_bits)),ob),
        [ss_num_columns, ss_num_rows, ss_base, ss_exp,
       ss_poly, ss_sbox_matrix, ss_affine_constant],
       namespace),rs)
  else
    rs : cons(
      cstt_new("ss_round_cst",
        append(ib,take_elements(num_block_bits,
            rest(ekBits,ss_num_rounds*num_block_bits)),ob),
        [ss_num_rounds, ss_num_columns, ss_num_rows, ss_base, ss_exp,
       ss_poly, ss_sbox_matrix, ss_affine_constant, ss_mixcolumns_matrix],
       namespace),rs),
  return(rs)
)$

/*
   SS Round

*/

ss_round_cstrb :
 [ss_round_cstr_cstl, ss_round_namespace, ss_round_ns_var_l]$

/* SS round namespace */
kill(ss_round_ns)$
declare(ss_round_ns,noun)$
declare(ss_round_ns,posfun)$
ss_round_namespace([args]) := apply(nounify(ss_round_ns),args)$

ss_round_ns_var_l(cst) := block([vars : [],namespace,
  ss_num_columns, ss_num_rows, ss_base, ss_exp, ss_poly,
  ss_sbox_matrix, ss_affine_constant, ss_mixcolumns_matrix, ss_arg_l,
  num_block_bits],
  ss_arg_l : cstt_args_l(cst),
  ss_num_columns : ss_arg_l[2],
  ss_num_rows : ss_arg_l[3],
  ss_exp : ss_arg_l[5],
  num_block_bits : ss_num_columns * ss_num_rows * ss_exp,
  namespace : cstt_namespace_new(ss_round_namespace,cst),
  vars : cons(generate_ss_constraint_vars(1,num_block_bits,
      namespace,nounify(so)),vars),
  vars : cons(generate_ss_constraint_vars(1,num_block_bits,
      namespace,nounify(ro)),vars),
  vars : cons(generate_ss_constraint_vars(1,num_block_bits,
      namespace,nounify(mo)),vars),
  return(lappend(vars)))$
/* Returns a set of conditions representing SS round given
   128 plaintext variables, 128 key variables and 128 output
   variables. */
ss_round_cstr_cstl(cst) := block(
  [namespace,bits,iBits, rkBits, oBits,tBits,rs:[],
  ss_num_columns, ss_num_rows, ss_base, ss_exp, ss_poly,
  ss_sbox_matrix, ss_affine_constant, ss_mixcolumns_matrix, ss_arg_l,
  num_block_bits],
  ss_arg_l : cstt_args_l(cst),
  ss_num_rounds : ss_arg_l[1],
  ss_num_columns : ss_arg_l[2],
  ss_num_rows : ss_arg_l[3],
  ss_base : ss_arg_l[4],
  ss_exp : ss_arg_l[5],
  ss_poly : ss_arg_l[6],
  ss_sbox_matrix : ss_arg_l[7],
  ss_affine_constant : ss_arg_l[8],
  ss_mixcolumns_matrix : ss_arg_l[9],
  num_block_bits : ss_num_columns * ss_num_rows * ss_exp,
  bits : cst[2],
  namespace : cstt_namespace_new(ss_round_namespace,cst),
  iBits : take_elements(num_block_bits,bits),
  rkBits : take_elements(num_block_bits,rest(bits,num_block_bits)),
  oBits : rest(bits,num_block_bits*2),
  tBits : generate_ss_constraint_vars(1,num_block_bits,namespace,nounify(so)),
  rs : cons(
    cstt_new("ss_subbytes_cst",
        append(iBits,tBits),
        [ss_base, ss_exp,
       ss_poly, ss_sbox_matrix, ss_affine_constant],namespace),
    rs),
  iBits : tBits,
  tBits : generate_ss_constraint_vars(1,num_block_bits,namespace,nounify(ro)),
  rs : cons(
    cstt_new("ss_shiftrows_cst",
        append(iBits,tBits),
        [ss_num_columns, ss_num_rows],namespace),
    rs),
  iBits : tBits,
  tBits : generate_ss_constraint_vars(1,num_block_bits,namespace,nounify(mo)),
  rs : cons(
    cstt_new("ss_mixcolumns_cst",
      append(iBits, tBits),
      [ss_num_columns, ss_num_rows, ss_base, ss_exp,
       ss_poly, ss_mixcolumns_matrix],namespace),
    rs),
  iBits : tBits,
  tBits : oBits,
  rs : cons(
    cstt_new("ss_add_cst",
      append(iBits, rkBits, tBits),
      [],namespace),
    rs),
  return(rs)
)$

/* TODO: Update below with small scale generalisations. */

/*
   SS Final round
   
*/

ss_final_round_cstrb :
 [ss_final_round_cstr_cstl, ss_final_round_namespace,ss_final_round_ns_var_l]$

/* SS final round namespace */
kill(ss_final_round_ns)$
declare(ss_final_round_ns,noun)$
declare(ss_final_round_ns,posfun)$
ss_final_round_namespace([args]) := apply(nounify(ss_final_round_ns),args)$

ss_final_round_ns_var_l(cst) := block(
  [vars : [],namespace,
  ss_num_columns, ss_num_rows, ss_base, ss_exp, ss_poly,
  ss_sbox_matrix, ss_affine_constant, ss_mixcolumns_matrix, ss_arg_l,
  num_block_bits],
  ss_arg_l : cstt_args_l(cst),
  ss_num_columns : ss_arg_l[1],
  ss_num_rows : ss_arg_l[2],
  ss_exp : ss_arg_l[4],
  num_block_bits : ss_num_columns * ss_num_rows * ss_exp,
  namespace : cstt_namespace_new(ss_final_round_namespace,cst),
  vars : cons(generate_ss_constraint_vars(1,num_block_bits,namespace,
      nounify(so)),vars),
  vars : cons(generate_ss_constraint_vars(1,num_block_bits,namespace,
      nounify(ro)),vars),
  return(lappend(vars)))$
/* Returns a set of conditions representing SS round given
   128 plaintext variables, 128 key variables and 128 output
   variables. */
ss_final_round_cstr_cstl(cst) := block(
  [namespace,bits,iBits, rkBits, oBits,tBits,rs:[],
  ss_num_columns, ss_num_rows, ss_base, ss_exp, ss_poly,
  ss_sbox_matrix, ss_affine_constant, ss_mixcolumns_matrix, ss_arg_l,
  num_block_bits],
  ss_arg_l : cstt_args_l(cst),
  ss_num_columns : ss_arg_l[1],
  ss_num_rows : ss_arg_l[2],
  ss_base : ss_arg_l[3],
  ss_exp : ss_arg_l[4],
  ss_poly : ss_arg_l[5],
  ss_sbox_matrix : ss_arg_l[6],
  ss_affine_constant : ss_arg_l[7],
  num_block_bits : ss_num_columns * ss_num_rows * ss_exp,
  bits : cst[2],
  namespace : cstt_namespace_new(ss_final_round_namespace,cst),
  iBits : take_elements(num_block_bits,bits),
  rkBits : take_elements(num_block_bits,rest(bits,num_block_bits)),
  oBits : rest(bits,num_block_bits*2),
  tBits : generate_ss_constraint_vars(1,num_block_bits,namespace,nounify(so)),
  rs : cons(
    cstt_new("ss_subbytes_cst",
        append(iBits,tBits),
        [ss_base, ss_exp,
       ss_poly, ss_sbox_matrix, ss_affine_constant],namespace),
    rs),
  iBits : tBits,
  tBits : generate_ss_constraint_vars(1,num_block_bits,namespace,nounify(ro)),
  rs : cons(
    cstt_new("ss_shiftrows_cst",
        append(iBits,tBits),
        [ss_num_columns, ss_num_rows],namespace),
    rs),
  iBits : tBits,
  tBits : oBits,
  rs : cons(
    cstt_new("ss_add_cst",
      append(iBits, rkBits, tBits),
      [],namespace),
    rs),
  return(rs)
)$

/*
   Subbytes
   
*/

ss_subbytes_cstrb :
 [ss_subbytes_cstr_cstl,ss_subbytes_namespace,ss_subbytes_ns_var_l]$


/* SS subbytes namespace */
kill(ss_subbytes_ns)$
declare(ss_subbytes_ns,noun)$
declare(ss_subbytes_ns,posfun)$
ss_subbytes_namespace([args]) := apply(nounify(ss_subbytes_ns),args)$

ss_subbytes_ns_var_l([a]) := []$
/* Returns a set of conditions representing the SS Subbytes operation given
   128 plaintext variables and 128 output variables. */
ss_subbytes_cstr_cstl(cst) := block(
  [namespace,bits,iBits, rkBits, oBits,tBits,rs:[],ss_arg_l, num_block_bits,
  num_words,ss_base, ss_exp,ss_poly, ss_sbox_matrix, ss_affine_constant],
  ss_arg_l : cstt_args_l(cst),
  ss_base : ss_arg_l[1],
  ss_exp : ss_arg_l[2],
  ss_poly : ss_arg_l[3],
  ss_sbox_matrix : ss_arg_l[4],
  ss_affine_constant : ss_arg_l[5],
  bits : cst[2],
  num_block_bits : floor(length(bits) / 2),
  num_words : floor(num_block_bits / ss_exp),
  namespace : cstt_namespace_new(ss_subbytes_namespace,cst),
  iBits : take_elements(num_block_bits,bits),
  oBits : rest(bits,num_block_bits),
  for i : 0 thru num_words - 1 do
    rs : cons(
      cstt_new("ss_sbox_cst",
        append(
          take_elements(ss_exp, rest(iBits,i*ss_exp)),
          take_elements(ss_exp, rest(oBits,i*ss_exp))),
        [ss_base, ss_exp,ss_poly, ss_sbox_matrix, ss_affine_constant, i],
        namespace),
      rs),
  return(rs)
)$


/*
   Shiftrows

*/

ss_shiftrows_cstrb :
 [ss_shiftrows_cstr_cstl,ss_shiftrows_namespace,ss_shiftrows_ns_var_l]$

/* SS shiftrows namespace */
kill(ss_shiftrows_ns)$
declare(ss_shiftrows_ns,noun)$
declare(ss_shiftrows_ns,posfun)$
ss_shiftrows_namespace(arg_l) := apply(nounify(ss_shiftrows_ns),arg_l)$


ss_shiftrows_ns_var_l([a]) := []$
/* Returns a set of conditions representing the SS Shiftrows operation given
   128 plaintext variables and 128 output variables. */
ss_shiftrows_cstr_cstl(cst) := block(
  [namespace,bits,iBits, oBits,count : 0, ss_arg_l, num_block_bits,
  ss_num_columns, ss_num_rows, ss_exp],
  ss_arg_l : cstt_args_l(cst),
  ss_num_columns : ss_arg_l[1],
  ss_num_rows : ss_arg_l[2],
  bits : cst[2],
  num_block_bits : floor(length(bits)/2),
  ss_exp : floor(num_block_bits / (ss_num_rows * ss_num_columns)),
  namespace : cstt_namespace_new(ss_shiftrows_namespace,cst),
  iBits : take_elements(num_block_bits,bits),
  oBits : take_elements(num_block_bits,rest(bits,num_block_bits)),
  map(
    lambda([a,b],
      cstt_new("eq_cst",[a,b],
        [],namespace)), oBits,
    lappend(
      rijn_m2l(ss_shiftrows(ss_l2m(
            partition_elements(iBits,ss_exp),ss_num_rows)))))
)$


/*
   Mixcolumns

*/

ss_mixcolumns_cstrb :
 [ss_mixcolumns_cstr_cstl,ss_mixcolumns_namespace,ss_mixcolumns_ns_var_l]$

/* SS mixcolumns namespace */
kill(ss_mixcolumns_ns)$
declare(ss_mixcolumns_ns,noun)$
declare(ss_mixcolumns_ns,posfun)$
ss_mixcolumns_namespace([arg_l]) := apply(nounify(ss_mixcolumns_ns),arg_l)$


ss_mixcolumns_ns_var_l([a]) := []$
/* Returns a set of conditions representing the SS Mixcolumns operation given
   128 plaintext variables and 128 output variables. */
ss_mixcolumns_cstr_cstl(cst) := block(
  [namespace, bits,iBits, oBits, mc_i : 0,ss_arg_l,
  ss_num_columns, ss_num_rows, ss_base, ss_exp, ss_column_size,
       ss_poly, ss_mixcolumns_matrix, num_block_bits],
  ss_arg_l : cstt_args_l(cst),
  ss_num_columns : ss_arg_l[1],
  ss_num_rows : ss_arg_l[2],
  ss_base : ss_arg_l[3],
  ss_exp : ss_arg_l[4],
  ss_poly : ss_arg_l[5],
  ss_mixcolumns_matrix : ss_arg_l[6],
  num_block_bits : ss_num_columns * ss_num_rows * ss_exp,
  ss_column_size : ss_num_rows * ss_exp,
  bits : cst[2],
  namespace : cstt_namespace_new(ss_mixcolumns_namespace,cst),
  iBits : take_elements(num_block_bits,bits),
  oBits : rest(bits,num_block_bits),
  map(lambda([a,b,column], 
    cstt_new("ss_mixcolumn_cst",
      append(lappend(a),lappend(b)),
      [ss_num_rows, ss_base, ss_exp,
       ss_poly, ss_mixcolumns_matrix, mc_i : mc_i + 1],namespace)),
    partition_elements(partition_elements(iBits,ss_exp),ss_num_rows),
    partition_elements(partition_elements(oBits,ss_exp),ss_num_rows),
    create_list(i,i,1,ss_num_columns))
)$


/*
   Bidirectional Mixcolumn

*/

ss_bi_mixcolumn_cstrb :
 [ss_bi_mixcolumn_cstr_cstl,ss_bi_mixcolumn_namespace,ss_bi_mixcolumn_ns_var_l]$


/* SS bi_mixcolumn namespace */
kill(ss_bi_mixcolumn_ns)$
declare(ss_bi_mixcolumn_ns,noun)$
declare(ss_bi_mixcolumn_ns,posfun)$
ss_bi_mixcolumn_namespace([args]) := apply(nounify(ss_bi_mixcolumn_ns),args)$

ss_bi_mixcolumn_ns_var_l(cstt) := block(
  [cstt_new : cstt_namespace_replace(cstt,
    cstt_namespace_new(ss_bi_mixcolumn_namespace,cstt))],
  append(
    ss_mixcolumn_ns_var_l(cstt_new),
    ss_inv_mixcolumn_ns_var_l(cstt_new)))$
/* Returns a set of conditions representing the SS bidirectional
   mixcolumn operation (the individual operation applied to a single column in
   SS bi_mixcolumns) given 128 plaintext variables and 128 output variables.
 */
ss_bi_mixcolumn_cstr_cstl(cstt) := block(
  [cstt_new : cstt_namespace_replace(cstt,
    cstt_namespace_new(ss_bi_mixcolumn_namespace,cstt))],
  append(
    ss_mixcolumn_cstr_cstl(cstt_new),
    ss_inv_mixcolumn_cstr_cstl(cstt_new)))$


/*
   Mixcolumn

*/

ss_mixcolumn_cstrb :
 [ss_mixcolumn_cstr_cstl,ss_mixcolumn_namespace,ss_mixcolumn_ns_var_l]$


/* SS mixcolumn namespace */
kill(ss_mixcolumn_ns)$
declare(ss_mixcolumn_ns,noun)$
declare(ss_mixcolumn_ns,posfun)$
ss_mixcolumn_namespace([args]) := apply(nounify(ss_mixcolumn_ns),args)$

ss_mixcolumn_ns_var_l(cst) := block([vars : [],namespace,ss_arg_l,
  ss_column_size,ss_num_rows, ss_base, ss_exp, ss_column_size,ss_poly,
  ss_mixcolumns_matrix],
  ss_arg_l : cstt_args_l(cst),
  ss_num_rows : ss_arg_l[1],
  ss_base : ss_arg_l[2],
  ss_exp : ss_arg_l[3],
  ss_poly : ss_arg_l[4],
  ss_mixcolumns_matrix : ss_arg_l[5],
  ss_column_size : ss_exp * ss_num_rows,
  namespace :
    cstt_namespace_new(ss_mixcolumn_namespace,cst),
  for i : 1 thru ss_num_rows do
    for j : 1 thru ss_num_rows do block([var_block],
      var_block : ss_column_size * (i-1) + ss_exp * (j-1),
      if ss_mixcolumns_matrix[i,j] # 1 then
        vars : cons(
          generate_ss_constraint_vars(
            var_block+1,var_block+ss_exp,namespace,nounify(mc)),vars)),
  return(lappend(vars)))$
/* Returns a set of conditions representing the SS Mixcolumn operation (the 
   individual operation applied to a single column in SS Mixcolumns) given
   128 plaintext variables and 128 output variables. */
ss_mixcolumn_cstr_cstl(cst) := block(
  [namespace,bits,iBits, oBits, nc,rs : [],ss_arg_l, ss_column_size,
  ss_num_rows, ss_base, ss_exp, ss_column_size,
       ss_poly, ss_mixcolumns_matrix],
  ss_arg_l : cstt_args_l(cst),
  ss_num_rows : ss_arg_l[1],
  ss_base : ss_arg_l[2],
  ss_exp : ss_arg_l[3],
  ss_poly : ss_arg_l[4],
  ss_mixcolumns_matrix : ss_arg_l[5],
  ss_column_size : ss_exp * ss_num_rows,
  bits : cst[2],
  namespace :
    cstt_namespace_new(ss_mixcolumn_namespace,cst),
  iBits : partition_elements(take_elements(ss_column_size, bits),ss_exp),
  oBits : partition_elements(rest(bits, ss_column_size), ss_exp),
  /* First element */
  for i : 1 thru ss_num_rows do block([mul_vars, mul_vars_l : []],
    for j : ss_num_rows thru 1 step -1 do block([var_block],
      var_block : ss_column_size * (i-1) + ss_exp * (j-1),
      if ss_mixcolumns_matrix[i,j] = 1 then
        mul_vars : iBits[j]
      else block(
        mul_vars :
          generate_ss_constraint_vars(var_block + 1,var_block + ss_exp,
            namespace,nounify(mc)),
        rs : cons(
              cstt_new("ss_mul_cst", append(iBits[j],mul_vars),
                  [ss_mixcolumns_matrix[i,j],ss_base,ss_exp, ss_poly,i,j],
                  namespace),
                rs)),
      mul_vars_l : cons(mul_vars, mul_vars_l)
    ),
    rs : cons(
      cstt_new("ss_add_cst",
        append(
          lappend(mul_vars_l),oBits[i]),[ss_num_rows], namespace),
      rs)
  ),
  return(rs)
)$


ss_mixcolumn_boolm_cstrb :
 [ss_mixcolumn_boolm_cstr_cstl,ss_mixcolumn_boolm_namespace,
  ss_mixcolumn_boolm_ns_var_l]$


/* MixColumns translation as a boolean matrix. */

kill(ss_mixcolumn_boolm_ns)$
declare(ss_mixcolumn_boolm_ns,noun)$
declare(ss_mixcolumn_boolm_ns,posfun)$
ss_mixcolumn_boolm_namespace([args]) :=
  apply(nounify(ss_mixcolumn_boolm_ns),args)$

ss_mixcolumn_boolm_ns_var_l(cst) := []$
ss_mixcolumn_boolm_cstr_cstl(cst) := block(
  [namespace,bits,iBits, oBits, nc,rs : [],ss_arg_l, ss_column_size,
   ss_num_rows, ss_base, ss_exp, ss_column_size, ss_poly,
   ss_mixcolumns_matrix, ss_mixcolumns_boolm_l, extract_vars],
  ss_arg_l : cstt_args_l(cst),
  ss_num_rows : ss_arg_l[1],
  ss_base : ss_arg_l[2],
  ss_exp : ss_arg_l[3],
  ss_poly : ss_arg_l[4],
  ss_mixcolumns_matrix : ss_arg_l[5],
  ss_column_size : ss_exp * ss_num_rows,
  bits : cst[2],
  namespace :
    cstt_namespace_new(ss_mixcolumn_boolm_namespace,cst),
  iBits : take_elements(ss_column_size, bits),
  oBits : rest(bits, ss_column_size),
  ss_mixcolumns_boolm_l :
    ss_mixcolumn_gen_boolm(ss_base,ss_exp,ss_poly,ss_mixcolumns_matrix),
  ss_mixcolumns_boolm_l : args(ss_mixcolumns_boolm_l),
  extract_vars(V,sublist_ind) :=
    delete(false,
      map(lambda([v,i], if i = 1 then v else false),V,sublist_ind)),
  /* First element */
  for i : 1 thru ss_column_size do block(
    [involved_vars : extract_vars(iBits,ss_mixcolumns_boolm_l[i])],
    rs : cons(
      cstt_new("ss_add_cst",
        endcons(oBits[i],involved_vars),
        [length(involved_vars)], namespace),
      rs)
  ),
  return(rs)
)$


/*
   Inverse Mixcolumn

*/

ss_inv_mixcolumn_cstrb :
 [ss_inv_mixcolumn_cstr_cstl,ss_inv_mixcolumn_namespace,ss_inv_mixcolumn_ns_var_l]$


/* SS inv_mixcolumn namespace */
kill(ss_inv_mixcolumn_ns)$
declare(ss_inv_mixcolumn_ns,noun)$
declare(ss_inv_mixcolumn_ns,posfun)$
ss_inv_mixcolumn_namespace([args]) := apply(nounify(ss_inv_mixcolumn_ns),args)$


ss_inv_mixcolumn_ns_var_l(cst) := block([vars : [],namespace,ss_arg_l,
  ss_column_size,ss_num_rows, ss_base, ss_exp, ss_column_size,ss_poly,
  ss_mixcolumns_matrix],
  ss_arg_l : cstt_args_l(cst),
  ss_num_rows : ss_arg_l[1],
  ss_base : ss_arg_l[2],
  ss_exp : ss_arg_l[3],
  ss_poly : ss_arg_l[4],
  ss_mixcolumns_matrix :
    ss_mixcolumns_matrix2inv_mixcolumns_matrix(ss_base,ss_exp,ss_arg_l[5]),
  ss_column_size : ss_exp * ss_num_rows,
  namespace :
    cstt_namespace_new(ss_inv_mixcolumn_namespace,cst),
  for i : 1 thru ss_num_rows do
    for j : 1 thru ss_num_rows do block([var_block],
      var_block : ss_column_size * (i-1) + ss_exp * (j-1),
      if ss_mixcolumns_matrix[i,j] # 1 then
        vars : cons(
          generate_ss_constraint_vars(
            var_block+1,var_block+ss_exp,namespace,nounify(mc)),vars)),
  return(lappend(vars)))$
/* Returns a set of conditions representing the SS Mixcolumn operation (the 
   individual operation applied to a single column in SS Mixcolumns) given
   128 plaintext variables and 128 output variables. */
ss_inv_mixcolumn_cstr_cstl(cst) := block(
  [namespace,bits,iBits, oBits, nc,rs : [],ss_arg_l, ss_column_size,
  ss_num_rows, ss_base, ss_exp, ss_column_size,
       ss_poly, ss_mixcolumns_matrix],
  ss_arg_l : cstt_args_l(cst),
  ss_num_rows : ss_arg_l[1],
  ss_base : ss_arg_l[2],
  ss_exp : ss_arg_l[3],
  ss_poly : ss_arg_l[4],
  ss_mixcolumns_matrix :
    ss_mixcolumns_matrix2inv_mixcolumns_matrix(ss_base,ss_exp,ss_arg_l[5]),
  ss_column_size : ss_exp * ss_num_rows,
  bits : cst[2],
  namespace :
    cstt_namespace_new(ss_inv_mixcolumn_namespace,cst),
  oBits : partition_elements(take_elements(ss_column_size, bits),ss_exp),
  iBits : partition_elements(rest(bits, ss_column_size), ss_exp),
  /* First element */
  for i : 1 thru ss_num_rows do block([mul_vars, mul_vars_l : []],
    for j : ss_num_rows thru 1 step -1 do block([var_block],
      var_block : ss_column_size * (i-1) + ss_exp * (j-1),
      if ss_mixcolumns_matrix[i,j] = 1 then
        mul_vars : iBits[j]
      else block(
        mul_vars :
          generate_ss_constraint_vars(var_block + 1,var_block + ss_exp,
            namespace,nounify(mc)),
        rs : cons(
              cstt_new("ss_mul_cst", append(iBits[j],mul_vars),
                  [ss_mixcolumns_matrix[i,j],ss_base,ss_exp, ss_poly,i,j],
                  namespace),
                rs)),
      mul_vars_l : cons(mul_vars, mul_vars_l)
    ),
    rs : cons(
      cstt_new("ss_add_cst",
        append(
          lappend(mul_vars_l),oBits[i]),[ss_num_rows], namespace),
      rs)
  ),
  return(rs)
)$

/*
   Key expansion

*/


ss_key_expansion_cstrb :
 [ss_key_expansion_cstr_cstl,ss_key_expansion_namespace,
  ss_key_expansion_ns_var_l]$

/* Generates a set of unit clauses (initially simpler than simplifying constants
   or making partial assignments) to set the given vars (representing the bits
   of SS round constants) to the round constant for round n */
ss_round_constant_l(n, b, e, mod_poly) := block([rc_el,rc_l],
  rc_el : xreduce(lambda([a,c],ss_natmul(c,a,b,mod_poly)),
               create_list(2,i,1,(n -1)),1),
  return(nat2vec_ss(rc_el,b,e))
)$

/* SS key expansion namespace */
kill(ss_key_expansion_ns)$
declare(ss_key_expansion_ns,noun)$
declare(ss_key_expansion_ns,posfun)$
ss_key_expansion_namespace([args]) :=
  apply(nounify(ss_key_expansion_ns),args)$

ss_key_expansion_ns_var_l(cst) := block(
  [vars : [],namespace,ss_arg_l,num_block_bits,
   ss_num_rounds, ss_num_columns, ss_num_rows, ss_base, ss_exp,
       ss_poly, ss_sbox_matrix, ss_affine_constant],
  ss_arg_l : cstt_args_l(cst),
  ss_num_rounds : ss_arg_l[1],
  ss_num_columns : ss_arg_l[2],
  ss_num_rows : ss_arg_l[3],
  ss_base : ss_arg_l[4],
  ss_exp : ss_arg_l[5],
  ss_poly : ss_arg_l[6],
  ss_sbox_matrix : ss_arg_l[7],
  ss_affine_constant : ss_arg_l[8],
  namespace : cstt_namespace_new(ss_key_expansion_namespace,cst),
  vars : cons(
    generate_ss_constraint_vars(1,ss_num_rows*ss_exp*ss_num_rounds,
      namespace,nounify(sb)),vars),
/*  vars : cons(
    generate_ss_constraint_vars(1,ss_exp*ss_num_rounds,namespace,nounify(ke)),
    vars),*/
  vars : cons(
    generate_ss_constraint_vars(1,ss_exp*ss_num_rounds,namespace,nounify(rc)),
    vars),
  return(lappend(vars)))$
/* Returns a set of conditions representing the SS keyschedule operation given
   128 key variables and 128 * (ss_num_rounds + 1) output variables
   (consecutive lots of 128 bits representing the individual round keys).
   
   The first 128 variables in the list "bits" represent the key block for the 
   cipher, and then the (i+1)'th consecutive 128 variables in "bits" represents
   the round key block for the i'th round. 
   
   */
ss_key_expansion_cstr_cstl(cst) := block(
  [namespace,bits, n_b : 4, n_r,kBits, rkBits, nc,rs : [],
   sboxVars, addVars,fMat, kMat, sbox_i : 0, rc_i : 0,ss_arg_l,num_block_bits,
   ss_num_rounds, ss_num_columns, ss_num_rows, ss_base, ss_exp,
       ss_poly, ss_sbox_matrix, ss_affine_constant],
  ss_arg_l : cstt_args_l(cst),
  ss_num_rounds : ss_arg_l[1],
  ss_num_columns : ss_arg_l[2],
  ss_num_rows : ss_arg_l[3],
  ss_base : ss_arg_l[4],
  ss_exp : ss_arg_l[5],
  ss_poly : ss_arg_l[6],
  ss_sbox_matrix : ss_arg_l[7],
  ss_affine_constant : ss_arg_l[8],
  num_block_bits : ss_exp * ss_num_columns * ss_num_rows,
  bits : cst[2],
  namespace : cstt_namespace_new(ss_key_expansion_namespace,cst),
  /* Primary Variables */
  kBits : take_elements(num_block_bits,bits),
  rkBits : rest(bits,num_block_bits),
  fBits : take_elements(num_block_bits,rkBits),
  /* Split into columns */
  cols :  partition_elements(partition_elements(rkBits,ss_exp),ss_num_rows),
  kMat : partition_elements(partition_elements(kBits,ss_exp),ss_num_rows),
  fMat : partition_elements(partition_elements(fBits,ss_exp),ss_num_rows),
  /* Make first round key equal */
  for j : 1 thru ss_num_columns do
    for i : 1 thru ss_num_rows do
      rs : cons(
        cstt_new("eq_cst",
          append(kMat[j][i], fMat[j][i]),
          [],namespace),
        rs),
  /* Setup output bits */
  for j : ss_num_columns thru (ss_num_columns * (ss_num_rounds +1)) - 1 do block(
    [var_offset],
    if mod(j, ss_num_columns) = 0 then block (
      var_offset : ((floor(j/ss_num_columns)-1)*ss_num_rows)*ss_exp,
      sboxVars : generate_ss_constraint_vars(
        var_offset +1,var_offset+ss_exp,namespace,nounify(sb)),
      rs : cons(
        cstt_new("ss_sbox_cst",
          append(cols[j][mod(1,ss_num_rows)+1], sboxVars),
          [ss_base, ss_exp,ss_poly, ss_sbox_matrix, ss_affine_constant,
          sbox_i : sbox_i + 1],namespace),
        rs),
      var_offset : floor(j/(ss_num_columns)-1)*(ss_exp), 
      rcVars : generate_ss_constraint_vars(
        var_offset + 1,var_offset + ss_exp,namespace,nounify(rc)),
      rs : cons(
        cstt_new("const_cst",
            rcVars,
            cons(rc_i : rc_i + 1,
              ss_round_constant_l(floor(j/ss_num_columns),ss_base, ss_exp,
                ss_poly)),
            namespace),
        rs),
      if ss_num_columns > 1 then
        rs : cons(
          cstt_new("ss_add_cst", 
            append(rcVars,cols[j-ss_num_columns+1][1],sboxVars, cols[j+1][1]),
            [3],namespace),
          rs)
      else
        rs : cons(
          cstt_new("ss_add_cst", 
            append(rcVars,sboxVars, cols[j+1][1]),
            [],namespace),
          rs),
      for i : 1 thru ss_num_rows-1 do block(
        [offset: ((floor(j/ss_num_columns)-1)*ss_num_rows + i)*ss_exp],
        sboxVars : generate_ss_constraint_vars(
          offset + 1,offset + ss_exp,namespace,nounify(sb)),
        rs : cons(
          cstt_new("ss_sbox_cst", 
            append(cols[j][mod(i+1,ss_num_rows)+1], sboxVars),
            [ss_base, ss_exp,ss_poly, ss_sbox_matrix, ss_affine_constant,
             sbox_i : sbox_i + 1],namespace),
          rs),
        if ss_num_columns > 1 then
          rs : cons(
            cstt_new("ss_add_cst", 
              append(cols[j-ss_num_columns+1][i+1],sboxVars, cols[j+1][i+1]),
              [],namespace),
            rs)
        else
          rs : cons(
            cstt_new("eq_cst", 
              append(sboxVars, cols[j+1][i+1]),
              [],namespace),
            rs)
      )
    )
    else for i : 1 thru ss_num_rows do 
      rs : cons(
        cstt_new("ss_add_cst",
          append(cols[j][i], cols[j-ss_num_columns+1][i],cols[j+1][i]),
          [],namespace),
        rs)
  ),
  return(rs)
)$

/* ****************************************
   * CNF Translation functions            *
   ****************************************
*/

ss_mul_ts_CNF : sm2hm({})$
ss_mul_ts_gen(p, b,e,mod_poly) := block([hash_key : [p+1,b,e,mod_poly]],
  if ev_hm_d(ss_mul_ts_CNF,hash_key,false) = false then
    block([plus16 : lambda([x],x+2*e),
      mul_dnf : ssmult_fulldnf_fcs(p,b,e,mod_poly)],
      set_hm(ss_mul_ts_CNF,hash_key,
        dualts_fcl(
          [listify(mul_dnf[1]),
          sort(
            listify(mul_dnf[2]),
            lambda([c,d], is(
                rank_lex_ksubsets(map(plus16,c),e*4) < 
                rank_lex_ksubsets(map(plus16,d),e*4)))
            )]
          )),
      return(ev_hm(ss_mul_ts_CNF,hash_key))
      ) else ev_hm(ss_mul_ts_CNF,hash_key))$

ss_sbox_ts_CNF : sm2hm({})$
ss_sbox_ts_gen(b,e,mod_poly) := block([hash_key : [b,e,mod_poly]],
  if ev_hm_d(ss_sbox_ts_CNF,hash_key,false) = false then
    block([plus16 : lambda([x],x+e*2),
      sbox_dnf : ss_sbox_fulldnf_fcs(b,e,mod_poly)],
      set_hm(ss_sbox_ts_CNF,hash_key,
        dualts_fcl(
          [listify(sbox_dnf[1]),
          sort(
            listify(sbox_dnf[2]),
            lambda([c,d], is(
                rank_lex_ksubsets(map(plus16,c),e*4) < 
                rank_lex_ksubsets(map(plus16,d),e*4)))
            )]
          )), 
        return(ev_hm(ss_sbox_ts_CNF,hash_key))
        ) else ev_hm(ss_sbox_ts_CNF,hash_key))$

ss_mixcolumn_ts_CNF : sm2hm({})$
ss_mixcolumn_ts_gen(b,e,mod_poly,mixcolumns_matrix) := block(
  [hash_key : [b,e,mod_poly,mixcolumns_matrix],num_rows],
  num_rows : length(mixcolumns_matrix),
  if ev_hm_d(ss_mixcolumn_ts_CNF,hash_key,false) = false then
    block([plus16 : lambda([x],x+2*e),
      mc_dnf :
        fcl2fcs(cl2fcl(bf2relation_fulldnf_cl(lambda([V],
            ss_mixcolumn_gen_bf(V,b,e,mod_poly,mixcolumns_matrix)),
          e*num_rows)))],
      set_hm(ss_mixcolumn_ts_CNF,hash_key,
        dualts_fcl(
          [listify(mc_dnf[1]),
          sort(
            listify(mc_dnf[2]),
            lambda([c,d], is(
                rank_lex_ksubsets(map(plus16,c),e*4) < 
                rank_lex_ksubsets(map(plus16,d),e*4)))
            )]
          )),
      return(ev_hm(ss_mixcolumn_ts_CNF,hash_key))
      ) else ev_hm(ss_mixcolumn_ts_CNF,hash_key))$

/* Returns a list of CNF clauses representing the sbox relation
   given the appropriate sbox constraint ("ss_sbox_cst" with 16 variables
   in the constraint).

   The clauses returned are those originally produced manually through
   experimentation into finding small Sbox representations (see plans
   and Sbox44ICCNF).
*/
ss_sbox_pi_cst_cl(cst) := block([ss_arg_l,
  ss_base, ss_exp,ss_poly, ss_sbox_matrix, ss_affine_constant],
  ss_arg_l : cstt_args_l(cst),  ss_exp : ss_arg_l[2],
  return(
    rename_fcl(map(listify,ev_hm(ss_sbox_cnfs,ss_exp)),cst[2])[2])
  )$

/* Takes an "ss_sbox_cst" constraint with the small scale base, exponent,
   modulo polynomial, sbox_matrix and affine constant and returns the
   smallest known (in terms of number of clauses) r_1 base for the AES Sbox
   with the given parameters.

   Note, this result may be undefined if an r_1 base has not be computed
   for the given parameters.
*/
ss_sbox_rbase_cst_cl(cst) := block([ss_arg_l,
  ss_base, ss_exp,ss_poly, ss_sbox_matrix, ss_affine_constant],
  ss_arg_l : cstt_args_l(cst),  ss_exp : ss_arg_l[2],
  return(
    rename_fcl(map(listify,ev_hm(ss_sbox_rbase_cnfs,ss_exp)),cst[2])[2])
  )$


/* SS sbox namespace */
kill(ss_sbox_ts_ns)$
declare(ss_sbox_ts_ns,noun)$
declare(ss_sbox_ts_ns,posfun)$
ss_sbox_ts_namespace([args]) :=
  apply(nounify(ss_sbox_ts_ns),args)$

/* Given an "ss_sbox_cst" constraint, returns the new variables
   introduced by "ss_sbox_ts_cst_cl" when given this constraint. */
ss_sbox_ts_var_l(cst) := block(
  [bits : cst[2],namespace],
  namespace : cstt_namespace_new(ss_sbox_ts_namespace,cst),
  generate_ss_constraint_vars(1,2^(length(bits)/2), namespace,
    nounify(sbox_ts)))$

/* Given an "ss_sbox_cst" constraint, returns a clause list
   generated by taking the canonical translation from DNF to CNF
   of the SS Sbox.
*/
ss_sbox_ts_cst_cl(cst) := block(
  [bits : cst[2],namespace,ss_arg_l,
  ss_base, ss_exp,ss_poly, ss_sbox_matrix, ss_affine_constant],
  ss_arg_l : cstt_args_l(cst),
  ss_base : ss_arg_l[1],
  ss_exp : ss_arg_l[2],
  ss_poly : ss_arg_l[3],
  namespace : cstt_namespace_new(ss_sbox_ts_namespace,cst),
  sbox : ss_sbox_ts_gen(ss_base,ss_exp,ss_poly),
  vars : append(bits,
    generate_ss_constraint_vars(1,2^(length(bits)/2), namespace,
      nounify(sbox_ts))),
  cnf : rename_fcl(sbox,vars),
  cnf[2])$

/* Takes an "ss_mul_cst" constraint with, as arguments, the field element e as
   a polynomial, the small scale base, exponent, modulo polynomial, and
   returns the smallest known (in terms of number of clauses) CNF for the
   multiplication by AES field element e with the given parameters. The CNF
   has as it's variables the variables given by the input constraint.
*/
ss_mul_pi_cst_cl(cst) := block([ss_arg_l,ss_element,
  ss_base, ss_exp,ss_poly],
  ss_arg_l : cstt_args_l(cst),
  ss_element : ss_arg_l[1],
  ss_base : ss_arg_l[2],
  ss_exp : ss_arg_l[3],
  ss_poly : ss_arg_l[4],
  return(
    rename_fcl(map(listify,ev_hm(ss_field_cnfs,
          [ss_exp,poly2nat(ss_element,ss_base)])),
      cst[2])[2])
  )$

/* Returns a list of CNF clauses representing the multiplication by 02
   given the appropriate constraint ("ss_mul2_cst" with 16 variables
   in the constraint).

   The clauses returned are those originally produced manually through
   experimentation into finding small Sbox representations (see plans
   and FieldMul2CNF).
*/
/* Takes an "ss_mul_cst" constraint with, as arguments, the field element e as
   a polynomial, the small scale base, exponent, modulo polynomial, and
   returns the smallest known (in terms of number of clauses) r_1 base for the
   AES field element e with the given parameters. The CNF has as it's
   variables the variables given by the input constraint.
*/
ss_mul_rbase_cst_cl(cst) := block([ss_arg_l,ss_element,
  ss_base, ss_exp,ss_poly],
  ss_arg_l : cstt_args_l(cst),
  ss_element : ss_arg_l[1],
  ss_base : ss_arg_l[2],
  ss_exp : ss_arg_l[3],
  ss_poly : ss_arg_l[4],
  return(
    rename_fcl(map(listify,ev_hm(ss_field_rbase_cnfs,
          [ss_exp,poly2nat(ss_element,ss_base)])),
      cst[2])[2])
  )$

kill(ss_mul_ts_ns)$
declare(ss_mul_ts_ns,noun)$
declare(ss_mul_ts_ns,posfun)$
ss_mul_ts_namespace([args]) :=
  apply(nounify(ss_mul_ts_ns),args)$

/* Given an "ss_mul_cst" constraint, returns the new variables
   introduced by "ss_mul_ts_cst_cl" when given this constraint. */
ss_mul_ts_var_l(cst) := block([bits : cst[2],namespace],
  namespace : cstt_namespace_new(ss_mul_ts_namespace,cst),
  generate_ss_constraint_vars(1,2^(length(bits)/2), namespace,nounify(mul_ts)))$

/* Returns a list of CNF clauses representing the multiplication by 02
   given the appropriate constraint ("ss_mul2_cst" with 16 variables
   in the constraint).

   The clauses returned are those given by the canonical translation
   using new variables. */
/* Takes an "ss_mul_cst" constraint with, as arguments, the field element e as
   a polynomial, the small scale base, exponent, modulo polynomial, and
   returns the canonical translation for multiplication by the AES field
   element e with the given parameters. 
*/
ss_mul_ts_cst_cl(cst) := block(
  [bits : cst[2],namespace,ss_arg_l,ss_base,ss_exp,ss_poly,ss_element],
  ss_arg_l : cstt_args_l(cst),
  ss_element : ss_arg_l[1],
  ss_base : ss_arg_l[2],
  ss_exp : ss_arg_l[3],
  ss_poly : ss_arg_l[4],
  namespace : cstt_namespace_new(ss_mul_ts_namespace,cst),
  rename_fcl(ss_mul_ts_gen(poly2nat(ss_element,ss_base),ss_base, ss_exp, ss_poly),
    append(bits,
      generate_ss_constraint_vars(1,2^(length(bits)/2),
        namespace,nounify(mul_ts))))[2])$


/* MixColumns translation using the canonical translation: */

kill(ss_mixcolumn_ts_ns)$
declare(ss_mixcolumn_ts_ns,noun)$
declare(ss_mixcolumn_ts_ns,posfun)$
ss_mixcolumn_ts_namespace([args]) :=
  apply(nounify(ss_mixcolumn_ts_ns),args)$

ss_mixcolumn_ts_var_l(cst) := block([bits : cst[2],namespace],
  namespace : cstt_namespace_new(ss_mixcolumn_ts_namespace,cst),
  generate_ss_constraint_vars(1,2^(length(bits)/2), namespace,nounify(mixcolumn_ts)))$

ss_mixcolumn_ts_cst_cl(cst) := block(
  [bits : cst[2],namespace,ss_arg_l,ss_base,ss_exp,ss_poly,ss_element],
  ss_arg_l : cstt_args_l(cst),
  ss_num_rows : ss_arg_l[1],
  ss_base : ss_arg_l[2],
  ss_exp : ss_arg_l[3],
  ss_poly : ss_arg_l[4],
  ss_mixcolumns_matrix : ss_arg_l[5],
  namespace : cstt_namespace_new(ss_mixcolumn_ts_namespace,cst),
  rename_fcl(ss_mixcolumn_ts_gen(ss_base, ss_exp, ss_poly,ss_mixcolumns_matrix),
    append(bits,
      generate_ss_constraint_vars(1,2^(length(bits)/2),
        namespace,nounify(mixcolumn_ts))))[2])$


/*!
\endhtmlonly
*/
