/* Oliver Kullmann, 29.11.2007 (Swansea) */
/* Copyright 2007, 2008 Oliver Kullmann
This file is part of the OKlibrary. OKlibrary is free software; you can redistribute
it and/or modify it under the terms of the GNU General Public License as published by
the Free Software Foundation and included in this library; either version 3 of the
License, or any later version. */

/*!
  \file ComputerAlgebra/Hypergraphs/Lisp/SetSystems.mac
  \brief Maxima functions for handling of set systems

Use by

oklib_load("Transitional/ComputerAlgebra/Hypergraphs/Lisp/SetSystems.mac");

*/

/*!
\htmlonly
*/

/* **************
   * Singletons *
   **************
*/

singletonp(S) := is(length(S) = 1)$
single_element(S) := listify(S)[1]$

choose_element(S) := listify(S)[1]$


/* *********************
   * Set constructions *
   *********************
*/

/* The set {1,...,n} */
setn(n) := if n <= 0 then {} else setify(makelist(i,i,1,n))$
/* The set {m, ..., n} */
setmn(m,n) := if n < m then {} else setify(makelist(i,i,m,n))$

/* A set of singletons from a set */
singletons(M) := makeset({x},[x],cartesian_product(M))$
/* All unordered pairs (possible degenerated) from two sets */
upairs(A,B) := makeset({x,y},[x,y],cartesian_product(A,B))$


/* **********************************
   * Constructions related to union *
   **********************************
*/

/* The union of a set system */
set_system_union(S) := if emptyp(S) then {} else xreduce(union, S)$

/* the union of a list of sets */
list_sets_union(L) := if emptyp(L) then {} else xreduce(union, L)$

/* the union of a family of sets (i.e., given is a domain I and a map f(i)).
   I can be a set or a list. */
family_sets_union(I, f) := if emptyp(I) then {} else block([res : {}],
 for i in I do res : union(res, f(i)), res)$

/* the sum of a list of sets */
set_sum(L) := block([I : setn(length(L))],
 family_sets_union(I, lambda([i], cartesian_product(L[i], {i}))))$
/* the n-ary version */
set_sumn([L]) := set_sum(L)$

/* Complex-union (pairwise union) */
cunion(A,B) := block([LA: listify(A), LB : listify(B)],
 makeset(ev(union(LA[i],LB[j]),noeval), [i,j],
  cartesian_product(setn(length(LA)),setn(length(LB)))))$
/* The special case of adding some set to all elements of
   a set system. */
add_elements(a,B) := cunion({a},B)$
/* Further specialised to adjoining a single element. */
add_element(x,B) := add_elements({x},B)$


/* ********************************************
   * Constructions related to complementation *
   ********************************************
*/

/* Elementwise complementation of set-system S w.r.t. universe U */
ecomp(S,U) := setify(makelist(setdifference(U,s),s,listify(S)))$

/* setdifference2(S,b) returns the set system where the elements of b have been
   removed from every element of S */
setdifference2(S,b) := map(lambda([s], setdifference(s,b)), S)$


/* *************************
   * Tests for set systems *
   *************************
*/

/* is_empty(S) is true iff S is the empty set system */
is_empty(S) := emptyp(S)$

/* has_empty_element(S) is true iff set system S contains the empty set */
has_empty_element(S) := some(emptyp, S)$

/* computes the first pair of indices of non-disjoint elements */
non_disjoint_pair(L) := block([l : length(L), nd : false, res : []],
  for i : 1 thru l-1 unless nd do block([A : L[i]], 
    for j : i+1 thru l unless nd do
      if not disjointp(A, L[j]) then (res : [i,j], nd : true)),
  return(res))$

/* whether S is a disjoint set system */
is_disjoint_set_system(S) := emptyp(non_disjoint_pair(listify(S)))$

/* whether S contains no subsumed elements */
is_antichain(S) := block([S : sort_length(listify(S)), l : length(S), i, j, subsumption : false, A],
  for i : 1 thru l-1 unless subsumption do (A : S[i],
    for j : i+1 thru l unless subsumption do
      if subsetp(A, S[j]) then subsumption : true),
  return(not subsumption)
)$


/* *****************************************
   * Constructions related to disjointness *
   *****************************************
*/

/* remove_with_element(S,a) is the subset of S of all sets not containing element a */
remove_with_element(S,a) := subset(S, lambda([s], not elementp(a,s)))$

/* more generally, remove_non_disjoint(S,b) is the subset of S of all sets
disjoint to b */
remove_non_disjoint(S,b) := subset(S, lambda([s], disjointp(s,b)))$

/* Replaces two elements by their union until the set system is disjoint */
unify_nondisjoint_elements(S) := block([L : listify(S), p, A, B],
  while not (p : non_disjoint_pair(L), emptyp(p)) do (
    A : L[p[1]], B : L[p[2]],
    L : delete(A,L), L : delete(B,L), L : append(L, [union(A,B)])),
  setify(L))$


/* *****************************************
   * Constructions related to subsumption *
   *****************************************
*/

/* The closure of a set system under subset-formation */
subset_closure(S) := family_sets_union(S, lambda([M],powerset(M)))$


/* Sorts the elements of a list according to their length (ascending) */
sort_length(L) := sort(L, lambda([A,B], length(A) <= length(B)))$
/* Sorts the elements of a list according to their length (descending) */
sort_length_desc(L) := sort(L, lambda([A,B], length(A) >= length(B)))$


/* Eliminates all subsumed elements from a set system */
min_elements(S) := block([remains : sort_length(listify(S)), result : [], A, not_subsumed],
 while not emptyp(remains) do (
  A : first(remains), remains : rest(remains),
  result : append(result, [A]),
  not_subsumed : sublist_indices(remains, lambda([B], not subsetp(A, B))),
  remains : makelist(remains[j], j, not_subsumed)),
  setify(result)
)$

/* Eliminates all contained elements from a set system */
max_elements(S) := block([remains : sort_length_desc(listify(S)), result : [], A, not_contained],
 while not emptyp(remains) do (
  A : first(remains), remains : rest(remains),
  result : append(result, [A]),
  not_contained : sublist_indices(remains, lambda([B], not subsetp(B, A))),
  remains : makelist(remains[j], j, not_contained)),
  setify(result)
)$


/*!
\endhtmlonly
*/
