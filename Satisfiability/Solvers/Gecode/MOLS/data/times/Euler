# Oleg Zaikin, 21.5.2021 (Irkutsk)

A)

Initial version (with minor editorial modifications) by Noah Rubin and Curtis Bright.

amd1:

MOLS$ RunTime ./2mols 6
program name:       2mols
 version:           0.1.2
 last change:       21.5.2021
 git-id:            8dc2ef335892dac1dc100606951e6fd44c01a1d1
machine name:       amd1
 bogomips:          7585.95
compiler version:   g++ 10.3.0
 date:              May_21_2021 13:41:20
 options:           "--std=c++20 -pedantic -Ofast -DNDEBUG -march=native -fwhole-program -fno-math-errno -fno-trapping-math -fno-rounding-math -fno-signaling-nans -fno-unsafe-math-optimizations -fno-finite-math-only -fno-associative-math -fno-reciprocal-math -fsigned-zeros -lgecodesearch -lgecodeint -lgecodekernel -lgecodesupport"
 NDEBUG:            defined
 OPTIMIZE:          on
Output program:
No solutions found
MIN + MAX user times:
0.14 0.16
MIN + MAX wallclock times:
0.15 0.16
MIN + MAX system times:
0.00 0.00

MOLS$ RunTime ./2mols 7
program name:       2mols
 version:           0.1.2
 last change:       21.5.2021
 git-id:            8dc2ef335892dac1dc100606951e6fd44c01a1d1
machine name:       amd1
 bogomips:          7585.95
compiler version:   g++ 10.3.0
 date:              May_21_2021 13:41:20
 options:           "--std=c++20 -pedantic -Ofast -DNDEBUG -march=native -fwhole-program -fno-math-errno -fno-trapping-math -fno-rounding-math -fno-signaling-nans -fno-unsafe-math-optimizations -fno-finite-math-only -fno-associative-math -fno-reciprocal-math -fsigned-zeros -lgecodesearch -lgecodeint -lgecodekernel -lgecodesupport"
 NDEBUG:            defined
 OPTIMIZE:          on
Output program:
0 1 2 3 4 5 6
1 0 3 6 5 4 2
2 3 5 0 6 1 4
3 4 1 5 2 6 0
4 2 6 1 0 3 5
5 6 0 4 1 2 3
6 5 4 2 3 0 1

0 1 2 3 4 5 6
2 3 1 5 0 6 4
3 5 4 6 2 0 1
4 0 6 1 5 3 2
5 6 0 4 1 2 3
6 4 5 2 3 1 0
1 2 3 0 6 4 5
MIN + MAX user times:
8.17 8.57
MIN + MAX wallclock times:
8.18 8.58
MIN + MAX system times:
0.00 0.00


B)

Version with fixed branching - now a variable with minimal domain size is really chosen.

amd1:

MOLS$ RunTime ./2mols 6
program name:       2mols
 version:           0.2.0
 last change:       21.5.2021
 git-id:            ad0ee4002413f5cf4db69e5f9e7a9fc8a56b5d91
machine name:       amd1
 bogomips:          7585.95
compiler version:   g++ 10.3.0
 date:              May_21_2021 16:22:05
 options:           "--std=c++20 -pedantic -Ofast -DNDEBUG -march=native -fwhole-program -fno-math-errno -fno-trapping-math -fno-rounding-math -fno-signaling-nans -fno-unsafe-math-optimizations -fno-finite-math-only -fno-associative-math -fno-reciprocal-math -fsigned-zeros -lgecodesearch -lgecodeint -lgecodekernel -lgecodesupport"
 NDEBUG:            defined
 OPTIMIZE:          on
Output program:
No solutions found
MIN + MAX user times:
0.62 0.64
MIN + MAX wallclock times:
0.62 0.64
MIN + MAX system times:
0.00 0.00

MOLS$ RunTime ./2mols 7
program name:       2mols
 version:           0.2.0
 last change:       21.5.2021
 git-id:            ad0ee4002413f5cf4db69e5f9e7a9fc8a56b5d91
machine name:       amd1
 bogomips:          7585.95
compiler version:   g++ 10.3.0
 date:              May_21_2021 16:22:05
 options:           "--std=c++20 -pedantic -Ofast -DNDEBUG -march=native -fwhole-program -fno-math-errno -fno-trapping-math -fno-rounding-math -fno-signaling-nans -fno-unsafe-math-optimizations -fno-finite-math-only -fno-associative-math -fno-reciprocal-math -fsigned-zeros -lgecodesearch -lgecodeint -lgecodekernel -lgecodesupport"
 NDEBUG:            defined
 OPTIMIZE:          on
Output program:
0 1 2 3 4 5 6
1 6 0 2 3 4 5
2 0 5 6 1 3 4
3 2 4 5 0 6 1
4 5 1 0 6 2 3
5 3 6 4 2 1 0
6 4 3 1 5 0 2

0 1 2 3 4 5 6
2 3 5 6 0 1 4
1 4 3 0 5 6 2
4 5 0 1 6 2 3
3 0 6 2 1 4 5
6 2 4 5 3 0 1
5 6 1 4 2 3 0
MIN + MAX user times:
0.11 0.12
MIN + MAX wallclock times:
0.11 0.12
MIN + MAX system times:
0.00 0.00


C)

Version with printing statistics and disabled symmetry breaking

okserver:

program name:       Euler
 version:           0.5.1
 last change:       26.7.2021
 git-id:            41ba9550441245415267b4023d2283373c7ba96e
machine name:       cs-kullmann-server.swan.ac.uk
 bogomips:          5400
compiler version:   g++ 10.2.0
 date:              Jul_26_2021 21:39:12
 options:           "--std=c++20 -pedantic -Ofast -DNDEBUG -march=native -fwhole-program -fno-math-errno -fno-trapping-math -fno-rounding-math -fno-signaling-nans -fno-unsafe-math-optimizations -fno-finite-math-only -fno-associative-math -fno-reciprocal-math -fsigned-zeros -lgecodesearch -lgecodeint -lgecodekernel -lgecodesupport"
 NDEBUG:            defined
 OPTIMIZE:          on

N k m1 m2 t    sat nds   lvs   ulvs  sol  inds  ptime  brt brsrc brm brsln prog  vers  opt
4 2 0 0 0.2021 1   55295 27648 20736 6912 27647 0.0002 0   0     0   1     Euler 0.5.1 "mind,eq,all"
4 2 0 0 0.1888 1   51809 27648 20736 6912 24161 0.0002 0   1     0   1     Euler 0.5.1 "mind,v,all"
4 2 0 0 5.4718 1   19751 7707  795   6912 12044 0.0002 1   0     0   1     Euler 0.5.1 "la,eq,mu0,all"
4 2 0 0 4.3104 1   14549 6914  2     6912 7635  0.0002 1   0     1   1     Euler 0.5.1 "la,eq,mu1,all"
4 2 0 0 1.2012 1   12549 6912  0     6912 5637  0.0001 1   1     0   1     Euler 0.5.1 "la,v,mu0,all"
4 2 0 0 2.6081 1   13605 6912  0     6912 6693  0.0000 1   1     1   1     Euler 0.5.1 "la,v,mu1,all"
4 2 0 0 3.9068 1   13701 6912  0     6912 6789  0.0002 1   2     0   1     Euler 0.5.1 "la,eqv,mu0,all"
4 2 0 0 6.5369 1   14757 6912  0     6912 7845  0.0002 1   2     1   1     Euler 0.5.1 "la,eqv,mu1,all"
N k m1 m2 opt              t          sat nds       lvs       ulvs      sol     inds      ptime brt brsrc brm brsln prog vers
5 2 0  0  "mind,eq,all"    1229.9210  1   290307359 145153680 138932880 6220800 145153679 0.0002 0 0 0 1 Euler 0.5.1
5 2 0  0  "mind,v,all"     1230.3216  1   265625486 145153680 138932880 6220800 120471806 0.0001 0 1 0 1 Euler 0.5.1
5 2 0  0  "la,eq,mu0,all"  > 50000 (interrupted)
5 2 0  0  "la,eq,mu1,all"  45115.117  1   57807062  8829310   2608510   6220800 48977752  0.0003 1 0 1 1 Euler 0.5.1
5 2 0  0  "la,v,mu0,all"   4380.6554  1   14238531  6739200   518400    6220800 7499331   0.0002 1 1 0 1 Euler 0.5.1
5 2 0  0  "la,v,mu1,all"   10387.0628 1   23768231  9868800   3648000   6220800 13899431  0.0002 1 1 1 1 Euler 0.5.1
5 2 0  0  "la,eqv,mu0,all" 10739.7923 1   18151371  6739200   518400    6220800 11412171  0.0001 1 2 0 1 Euler 0.5.1
5 2 0  0  "la,eqv,mu1,all" 45140.2733 1   60608531  8494800   2274000   6220800 52113731  0.0002 1 2 1 1 Euler 0.5.1

Comments:
1. The problem is to enumerate all MOLS for given order N.
2. The number of solution is the same for all strategies.
3. mind,v (mind stands for 'choosing for branching a variable with minimal domain size', v stands for
with 'value-branches') results is smaller number of nodes compared with mind,eq (with equality-branches),
the time is similar.
4. mind is faster than lookahead, but lookahead results in much smaller number of nodes: about 4x for N=4
and 4x-14x for N=5.
5. The best lookahead strategy (in sense of runtime and the number of nodes) is la,v,mu0 for both for N=4
and N=5, the worst is la,eq,mu0 (at least for the number of nodes; on N=4 runtime on la,eqv,mu1 is a bit
higher).


D)

Version with option for propagation level

okserver:

program name:       Euler
 version:           0.6.2
 last change:       10.8.2021
 git-id:            789380e6ea619c4b886a2763f4e48060c247d84e
machine name:       cs-kullmann-server.swan.ac.uk
 bogomips:          5400
compiler version:   g++ 10.2.0
 date:              Aug_10_2021 13:43:00
 options:           "--std=c++20 -pedantic -Ofast -DNDEBUG -march=native -fwhole-program -fno-math-errno -fno-trapping-math -fno-rounding-math -fno-signaling-nans -fno-unsafe-math-optimizations -fno-finite-math-only -fno-associative-math -fno-reciprocal-math -fsigned-zeros -lgecodesearch -lgecodeint -lgecodekernel -lgecodesupport"
 NDEBUG:            defined
 OPTIMIZE:          on


MOLS> ./Euler 4 2 mind,eq,all -sol def
N k m1 m2 brt brsrc brm brsol prp t sat nds inds lvs ulvs sol chcs taus sbps chct taut sbpt prpt ptime prog vers
4 2 0 0 mind eq "" all def 0.3683 1 55295 27647 27648 20736 6912 27647 0 0 0.0304 0.0000 0.0000 0.0000 0.0000 Euler 0.6.2
MOLS> ./Euler 4 2 mind,eq,all -sol val
N k m1 m2 brt brsrc brm brsol prp t sat nds inds lvs ulvs sol chcs taus sbps chct taut sbpt prpt ptime prog vers
4 2 0 0 mind eq "" all val 0.3626 1 55295 27647 27648 20736 6912 27647 0 0 0.0299 0.0000 0.0000 0.0000 0.0000 Euler 0.6.2
MOLS> ./Euler 4 2 mind,eq,all -sol bnd
N k m1 m2 brt brsrc brm brsol prp t sat nds inds lvs ulvs sol chcs taus sbps chct taut sbpt prpt ptime prog vers
4 2 0 0 mind eq "" all bnd 0.7079 1 55295 27647 27648 20736 6912 27647 0 0 0.0327 0.0000 0.0000 0.0000 0.0002 Euler 0.6.2
MOLS> ./Euler 4 2 mind,eq,all -sol dom
N k m1 m2 brt brsrc brm brsol prp t sat nds inds lvs ulvs sol chcs taus sbps chct taut sbpt prpt ptime prog vers
4 2 0 0 mind eq "" all dom 0.6833 1 55295 27647 27648 20736 6912 27647 0 0 0.0321 0.0000 0.0000 0.0000 0.0002 Euler 0.6.2

MOLS> ./Euler 4 2 la,eq,all -sol def
N k m1 m2 brt brsrc brm brsol prp t sat nds inds lvs ulvs sol chcs taus sbps chct taut sbpt prpt ptime prog vers
4 2 0 0 la eq mu0 all def 11.6509 1 19751 12044 7707 795 6912 12839 507957 1036398 11.4397 2.4427 3.8041 0.0000 0.0002 Euler 0.6.2
MOLS> ./Euler 4 2 la,eq,all -sol val
N k m1 m2 brt brsrc brm brsol prp t sat nds inds lvs ulvs sol chcs taus sbps chct taut sbpt prpt ptime prog vers
4 2 0 0 la eq mu0 all val 11.4813 1 23183 14901 8282 1370 6912 16271 596752 1219702 11.2890 2.7700 4.3333 0.0000 0.0002 Euler 0.6.2
MOLS> ./Euler 4 2 la,eq,all -sol bnd
N k m1 m2 brt brsrc brm brsol prp t sat nds inds lvs ulvs sol chcs taus sbps chct taut sbpt prpt ptime prog vers
4 2 0 0 la eq mu0 all bnd 10.1919 1 17048 10037 7011 99 6912 10136 402020 820424 9.9850 1.6360 3.0147 0.0000 0.0002 Euler 0.6.2
MOLS> ./Euler 4 2 la,eq,all -sol dom
N k m1 m2 brt brsrc brm brsol prp t sat nds inds lvs ulvs sol chcs taus sbps chct taut sbpt prpt ptime prog vers
4 2 0 0 la eq mu0 all dom 9.6047 1 15310 8398 6912 0 6912 8398 369777 752416 9.4217 1.5913 2.2704 0.0000 0.0002 Euler 0.6.2

MOLS> ./Euler 5 2 mind,eq,all -sol def
N k m1 m2 brt brsrc brm brsol prp t sat nds inds lvs ulvs sol chcs taus sbps chct taut sbpt prpt ptime prog vers
5 2 0 0 mind eq "" all def 1930.7025 1 290307359 145153679 145153680 138932880 6220800 145153679 0 0 159.8531 0.0000 0.0000 0.0000 0.0002 Euler 0.6.2
MOLS> ./Euler 5 2 mind,eq,all -sol dom
N k m1 m2 brt brsrc brm brsol prp t sat nds inds lvs ulvs sol chcs taus sbps chct taut sbpt prpt ptime prog vers
5 2 0 0 mind eq "" all dom 3493.1540 1 157593599 78796799 78796800 72576000 6220800 78796799 0 0 106.5693 0.0000 0.0000 0.0000 0.0000 Euler 0.6.2

Comments:
1. For the minimal-domain-size branching strategy on order 4, propagation level do not change the number of nodes.
2. For look-ahead, the propagation level is crucial: the best results (both time-wise and node-wise) are on the
   most powerful level (domain-propagation), while the worst results are on the weakest one (values-propagation).
3. For order 5 and the mind branching, the domain propagation imrpoved the number of nodes, but impaired the runtime.
   By now it seems that the domain propagation really makes sense only on look-ahead.

oz-campus-desktop

program name:       Euler
 version:           0.6.2
 last change:       10.8.2021
 git-id:            bc2dd0ea3733a05f26fc45b2363395abbfe71866
machine name:       cs2-lnx-8cc0131zlv
 bogomips:          6000
compiler version:   g++ 10.3.0
 date:              Aug_10_2021 13:38:00
 options:           "--std=c++20 -pedantic -Ofast -DNDEBUG -march=native -fwhole-program -fno-math-errno -fno-trapping-math -fno-rounding-math -fno-signaling-nans -fno-unsafe-math-optimizations -fno-finite-math-only -fno-associative-math -fno-reciprocal-math -fsigned-zeros -lgecodesearch -lgecodeint -lgecodekernel -lgecodesupport"
 NDEBUG:            defined
 OPTIMIZE:          on

equality branching strategy, default-propagation:
MOLS$ LSRG 6,2 "-co" "1*0,0,36;1*0,0,0" 0 | ./Euler 0 2 la,eq,mu0,all "" def
N k m1 m2 brt brsrc brm brsol prp t sat nds inds lvs ulvs sol chcs taus sbps chct taut sbpt prpt ptime prog vers
6 2 36 0 la eq mu0 all def 1075.1247 0 2482366 2146637 335729 335729 0 2482366 94738901 193771078 1070.6321 286.3867 477.8685 0.0000 0.0000 Euler 0.6.2

equality branching strategy, domain-propagation:
MOLS$ LSRG 6,2 "-co" "1*0,0,36;1*0,0,0" 0 | ./Euler 0 2 la,eq,mu0,all "" dom
N k m1 m2 brt brsrc brm brsol prp t sat nds inds lvs ulvs sol chcs taus sbps chct taut sbpt prpt ptime prog vers
6 2 36 0 la eq mu0 all dom 4.0760 0 2833 2483 350 350 0 2833 151312 307592 4.0590 0.5145 0.7776 0.0000 0.0002 Euler 0.6.2

values branching strategy, default-propagation:
MOLS$ LSRG 6,2 "-co" "1*0,0,36;1*0,0,0" 0 | ./Euler 0 2 la,val,mu0,all "" def
N k m1 m2 brt brsrc brm brsol prp t sat nds inds lvs ulvs sol chcs taus sbps chct taut sbpt prpt ptime prog vers
6 2 36 0 la val mu0 all def 14.4776 0 54517 34357 20160 20160 0 54517 734052 2695332 14.3194 2.6866 5.9643 0.0000 0.0002 Euler 0.6.2

values branching strategy, domain-propagation:
MOLS$ LSRG 6,2 "-co" "1*0,0,36;1*0,0,0" 0 | ./Euler 0 2 la,val,mu0,all "" dom
N k m1 m2 brt brsrc brm brsol prp t sat nds inds lvs ulvs sol chcs taus sbps chct taut sbpt prpt ptime prog vers
6 2 36 0 la val mu0 all dom 6.4721 0 5557 2677 2880 2880 0 5557 94692 403572 6.3823 0.3233 1.0002 0.0000 0.0000 Euler 0.6.2

equality+values branching strategy, default-propagation:
MOLS$ LSRG 6,2 "-co" "1*0,0,36;1*0,0,0" 0 | ./Euler 0 2 la,eqval,mu0,all "" def
N k m1 m2 brt brsrc brm brsol prp t sat nds inds lvs ulvs sol chcs taus sbps chct taut sbpt prpt ptime prog vers
6 2 36 0 la eqval mu0 all def 33.1641 0 106777 98137 8640 8640 0 106777 3281850 5262096 32.9864 10.3164 12.9923 0.0000 0.0002 Euler 0.6.2

equality+values branching strategy, domain-propagation:
MOLS$ LSRG 6,2 "-co" "1*0,0,36;1*0,0,0" 0 | ./Euler 0 2 la,eqval,mu0,all "" dom
N k m1 m2 brt brsrc brm brsol prp t sat nds inds lvs ulvs sol chcs taus sbps chct taut sbpt prpt ptime prog vers
6 2 36 0 la eqval mu0 all dom 16.4842 0 25183 22303 2880 2880 0 25183 758364 1260096 16.3107 2.5724 3.2252 0.0000 0.0005 Euler 0.6.2

Comments:
1. For all look-ahead variants, the domain propagation improved both runtime and the number of nodes.
   For la,eq,mu0,all, the improvement is extremely significant (4 vs 1075 seconds, 2833 vs 2482366 nodes).

oz-amd1:

program name:       Euler
 version:           0.7.1
 last change:       7.10.2021
 git-id:            7fbead111a084fbd89fdd60aad73328a8f130bfe
machine name:       amd1
 bogomips:          7585.41
compiler version:   g++ 10.3.0
 date:              Oct_8_2021 14:35:24
 options:           "--std=c++20 -pedantic -Ofast -DNDEBUG -march=native -fwhole-program -fno-math-errno -fno-trapping-math -fno-rounding-math -fno-signaling-nans -fno-unsafe-math-optimizations -fno-finite-math-only -fno-associative-math -fno-reciprocal-math -fsigned-zeros -DGIST=0 -lgecodesearch -lgecodeint -lgecodekernel -lgecodesupport"
 NDEBUG:            defined
 OPTIMIZE:          on

MOLS$ LSRG 6,2 "-co" "1*0,0,36;1*0,0,0" 0 | ./Euler 0 2 la,eq,mu0,all
N k m1 m2 brt brsrc brm brsol prp t sat nds inds lvs ulvs sol chcs taus sbps chct taut sbpt ptime prog vers
6 2 36 0 la eq mu0 all dom 3.3801 0 3183 2833 350 350 0 2833 151312 307592 3.3664 0.5570 0.5695 0.0002 Euler 0.7.1

MOLS$ ./Euler 4 2 la,eq,all,mu0
N k m1 m2 brt brsrc brm brsol prp t sat nds inds lvs ulvs sol chcs taus sbps chct taut sbpt ptime prog vers
4 2 0 0 la eq mu0 all dom 3.7531 1 15310 8398 6912 0 6912 8398 369777 752416 3.6944 1.0711 0.8474 0.0000 Euler 0.7.1


E)

Version with collecting and applying all single-child branchings before calculating ltau for the remaining branchings.

oz-amd1:

MOLS$ LSRG 6,2 "-co" "1*0,0,36;1*0,0,0" 0 | ./Euler 0 2 la,eq,mu0,all
N k m1 m2 brt brsrc brm brsol prp t sat nds inds lvs ulvs sol chcs taus sbps chct taut sbpt ptime prog vers
6 2 36 0 la eq mu0 all dom 6.8100 0 1761 1627 134 134 0 1627 120098 387006 6.7982 0.4005 3.9348 0.0001 Euler 0.7.2

Comments:
1. On this instance, the number of nodes decreased from 3183 to 1761, ltau calls - from 151312 to 120098.


F)

Version with collecting and applying all single-child branchings iteratively before calculating ltau.
Now no redundant nodes are created for these single-child branchings.

oz-amd1:

program name:       Euler
 version:           0.7.3
 last change:       15.10.2021
 git-id:            8165c28eb5ba36680deedb329794ed99374f9aec
machine name:       amd1
 bogomips:          7585.41
compiler version:   g++ 10.3.0
 date:              Oct_15_2021 18:02:08
 options:           "--std=c++20 -pedantic -Ofast -DNDEBUG -march=native -fwhole-program -fno-math-errno -fno-trapping-math -fno-rounding-math -fno-signaling-nans -fno-unsafe-math-optimizations -fno-finite-math-only -fno-associative-math -fno-reciprocal-math -fsigned-zeros -DGIST=0 -lgecodesearch -lgecodeint -lgecodekernel -lgecodesupport"
 NDEBUG:            defined
 OPTIMIZE:          on

MOLS$ LSRG 6,2 "-co" "1*0,0,36;1*0,0,0" 0 | ./Euler 0 2 la,eq,mu0,all
N k m1 m2 brt brsrc brm brsol prp t sat nds inds lvs ulvs sol chcs taus sbps chct taut sbpt ptime prog vers
6 2 36 0 la eq mu0 all dom 3.9845 0 833 699 134 134 0 699 120098 387006 3.9719 0.4392 0.7659 0.0000 Euler 0.7.3

Comments:
1. On this instance, the number of nodes decreased from 1761 to 833, while ltau calls is the same: 120098.


G)

Version with assigning immediately var==value if var!=value failed.

oz-amd1:

program name:       Euler
 version:           0.7.5
 last change:       18.10.2021
 git-id:            87fd68b0b540932a6478445b8a66e693487b0cd7
machine name:       amd1
 bogomips:          7585.41
compiler version:   g++ 10.3.0
 date:              Oct_18_2021 16:47:36
 options:           "--std=c++20 -pedantic -Ofast -DNDEBUG -march=native -fwhole-program -fno-math-errno -fno-trapping-math -fno-rounding-math -fno-signaling-nans -fno-unsafe-math-optimizations -fno-finite-math-only -fno-associative-math -fno-reciprocal-math -fsigned-zeros -DGIST=0 -lgecodesearch -lgecodeint -lgecodekernel -lgecodesupport"
 NDEBUG:            defined
 OPTIMIZE:          on

MOLS$ LSRG 6,2 "-co" "1*0,0,36;1*0,0,0" 0 | ./Euler 0 2 la,eq,mu0,all
N k m1 m2 brt brsrc brm brsol prp t sat nds inds lvs ulvs sol chcs taus sbps chct taut sbpt ptime prog vers
6 2 36 0 la eq mu0 all dom 3.8259 0 699 699 0 0 0 699 120098 354680 3.8132 0.4474 0.7292 0.0002 Euler 0.7.5

Comments:
1. Unsatisfiable leaves do not exist anymore because they are catched and processed on the fly.
2. The number of created subproblems decreased from 387006 to 354680, i.e. by about 8.5 %.


H)

Removed redundant members.

program name:       Euler
 version:           0.7.6
 last change:       18.10.2021
 git-id:            a62f2ce2e04831e71c33b9baa7ff2d575e94aece
machine name:       amd1
 bogomips:          7585.41
compiler version:   g++ 10.3.0
 date:              Oct_18_2021 17:36:28
 options:           "--std=c++20 -pedantic -Ofast -DNDEBUG -march=native -fwhole-program -fno-math-errno -fno-trapping-math -fno-rounding-math -fno-signaling-nans -fno-unsafe-math-optimizations -fno-finite-math-only -fno-associative-math -fno-reciprocal-math -fsigned-zeros -DGIST=0 -lgecodesearch -lgecodeint -lgecodekernel -lgecodesupport"
 NDEBUG:            defined
 OPTIMIZE:          on

oz-amd1:

MOLS$ LSRG 6,2 "-co" "1*0,0,36;1*0,0,0" 0 | ./Euler 0 2 la,eq,mu0,all
N k m1 m2 brt brsrc brm brsol prp t sat nds inds lvs ulvs sol chcs taus sbps chct taut sbpt ptime prog vers
6 2 36 0 la eq mu0 all dom 3.6917 0 699 699 0 0 0 699 120098 354680 3.6799 0.4471 0.6609 0.0002 Euler 0.7.6

MOLS$ ./Euler 4 2 la,eq,mu0,all
N k m1 m2 brt brsrc brm brsol prp t sat nds inds lvs ulvs sol chcs taus sbps chct taut sbpt ptime prog vers
4 2 0 0 la eq mu0 all dom 8.6549 1 14477 7565 6912 0 6912 7565 504883 2054696 8.5749 1.2097 2.2183 0.0001 Euler 0.7.6

Comments:
1. Runtime slighlty improved.


I)

Simulated behaviour of 0.7.1 (with redundant single-child-nodes).

program name:       Euler
 version:           0.7.7
 last change:       20.10.2021
 git-id:            bfc12141641dceb9fdf59e05edfba08908676eb0
machine name:       amd1
 bogomips:          7585.65
compiler version:   g++ 10.3.0
 date:              Oct_20_2021 17:55:39
 options:           "--std=c++20 -pedantic -Ofast -DNDEBUG -march=native -fwhole-program -fno-math-errno -fno-trapping-math -fno-rounding-math -fno-signaling-nans -fno-unsafe-math-optimizations -fno-finite-math-only -fno-associative-math -fno-reciprocal-math -fsigned-zeros -DGIST=0 -lgecodesearch -lgecodeint -lgecodekernel -lgecodesupport"
 NDEBUG:            defined
 OPTIMIZE:          on

oz-amd1:

MOLS$ LSRG 6,2 "-co" "1*0,0,36;1*0,0,0" 0 | ./Euler 0 2 la,eq,mu0,all
N k m1 m2 brt brsrc brm brsol prp t sat nds inds lvs ulvs sol chcs taus sbps chct taut sbpt ptime prog vers
6 2 36 0 la eq mu0 all dom 3.4292 0 1049 699 350 350 0 699 120098 307592 3.4182 0.5287 0.5887 0.0001 Euler 0.7.7

MOLS$ ./Euler 4 2 eq,all
N k m1 m2 brt brsrc brm brsol prp t sat nds inds lvs ulvs sol chcs taus sbps chct taut sbpt ptime prog vers
4 2 0 0 la eq mu0 all dom 3.6576 1 13894 6981 6913 1 6912 6981 213883 836858 3.5885 0.6197 0.9310 0.0001 Euler 0.7.7

Comments:
1. Time on order 4 significanlty improved.
2. On order 6, the number of subproblems is equal to that on 0.7.1.
   On order 4, the number is still slightly bigger.


J)

New option - eager/lazy applying of single-child branchings.
In both versions ltau is called only if not single-child branching is found.

program name:       Euler
 version:           0.8.4
 last change:       27.10.2021
 git-id:            ccf9265533416ff3e06cf0bd92678808c477c25c
machine name:       amd1
 bogomips:          7585.65
compiler version:   g++ 10.3.0
 date:              Oct_27_2021 17:30:49
 options:           "--std=c++20 -pedantic -Ofast -DNDEBUG -march=native -fwhole-program -fno-math-errno -fno-trapping-math -fno-rounding-math -fno-signaling-nans -fno-unsafe-math-optimizations -fno-finite-math-only -fno-associative-math -fno-reciprocal-math -fsigned-zeros -DGIST=0 -lgecodesearch -lgecodeint -lgecodekernel -lgecodesupport"
 NDEBUG:            defined
 OPTIMIZE:          on

oz-amd1:

MOLS$ ./Euler 4 2 eq,all,eager
N k m1 m2 brt brsrc brm brsol bregr prp t sat nds inds inds2 inds3 lvs ulvs sol 1chld chcs taus sbps chct taut sbpt ptime prog vers
4 2 0 0 la eq mu0 all eager dom 3.3662 1 13823 6911 6911 0 6912 0 6912 1487 8398 213883 752416 3.2917 0.6292 0.8515 0.0001 Euler 0.8.4

MOLS$ ./Euler 4 2 eq,all,lazy
N k m1 m2 brt brsrc brm brsol bregr prp t sat nds inds inds2 inds3 lvs ulvs sol 1chld chcs taus sbps chct taut sbpt ptime prog vers
4 2 0 0 la eq mu0 all lazy dom 3.1472 1 13823 6911 6911 0 6912 0 6912 396 7307 213883 700678 3.0766 0.6214 0.7772 0.0001 Euler 0.8.4

MOLS$ LSRG 6,2 "-co" "1*0,0,36;1*0,0,0" 0 | ./Euler 0 2 la,eq,mu0,all,eager
N k m1 m2 brt brsrc brm brsol bregr prp t sat nds inds inds2 inds3 lvs ulvs sol 1chld chcs taus sbps chct taut sbpt ptime prog vers
6 2 36 0 la eq mu0 all eager dom 3.3702 0 699 349 349 0 350 350 0 2484 2833 120098 307592 3.3510 0.4465 0.5856 0.0001 Euler 0.8.4

MOLS$ LSRG 6,2 "-co" "1*0,0,36;1*0,0,0" 0 | ./Euler 0 2 la,eq,mu0,all,lazy
N k m1 m2 brt brsrc brm brsol bregr prp t sat nds inds inds2 inds3 lvs ulvs sol 1chld chcs taus sbps chct taut sbpt ptime prog vers
6 2 36 0 la eq mu0 all lazy dom 4.1527 0 699 349 349 0 350 350 0 357 706 120098 387006 4.1379 0.5053 0.7413 0.0000 Euler 0.8.4

Comments:
1. On order 4, lazy is faster than eager, while on order 6 eager is faster.
2. The number of nodes and ltau calls are equal in both cases.


H)

In equality-based lookahead, var!=val implies var==val, so other values of var
are skipped.

program name:       Euler
 version:           0.8.5
 last change:       27.10.2021
 git-id:            a68923e7e75725bbf3a5011b2dee238866eef754
machine name:       amd1
 bogomips:          7585.65
compiler version:   g++ 10.3.0
 date:              Oct_27_2021 17:56:24
 options:           "--std=c++20 -pedantic -Ofast -DNDEBUG -march=native -fwhole-program -fno-math-errno -fno-trapping-math -fno-rounding-math -fno-signaling-nans -fno-unsafe-math-optimizations -fno-finite-math-only -fno-associative-math -fno-reciprocal-math -fsigned-zeros -DGIST=0 -lgecodesearch -lgecodeint -lgecodekernel -lgecodesupport"
 NDEBUG:            defined
 OPTIMIZE:          on

oz-amd1:

MOLS$ ./Euler 4 2 eq,all,lazy
N k m1 m2 brt brsrc brm brsol bregr prp t sat nds inds inds2 inds3 lvs ulvs sol 1chld chcs taus sbps chct taut sbpt ptime prog vers
4 2 0 0 la eq mu0 all lazy dom 3.1929 1 13823 6911 6911 0 6912 0 6912 396 7307 213883 699408 3.1226 0.6299 0.7970 0.0001 Euler 0.8.5

MOLS$ LSRG 6,2 "-co" "1*0,0,36;1*0,0,0" 0 | ./Euler 0 2 la,eq,mu0,all,lazy
N k m1 m2 brt brsrc brm brsol bregr prp t sat nds inds inds2 inds3 lvs ulvs sol 1chld chcs taus sbps chct taut sbpt ptime prog vers
6 2 36 0 la eq mu0 all lazy dom 3.9890 0 699 349 349 0 350 350 0 357 706 120098 386422 3.9730 0.4479 0.7178 0.0001 Euler 0.8.5

Comments:
1. The number of subproblems (sbps) is slightly better.


I)

Eager/lazy mode for all lookahead variants: eq, val, eqval.

Version 0.9.0.

okserver:

1000 random instances, MOLS of order 7, 18 cells in the first LS are known (as in the
Latin Squares repository).

                time-unsat               time-sat                 nds-unsat                 nds-sat
                avg   min  max    sd     avg   min  max    sd     avg     min max  sd       avg     min max   sd
eqval,mu0,eager 18.82 0.37 231.2  24.81  23.58 0.22 458.63 43.13  917.83  20  7033 879.13   905.97  4   9462  1150.88
eqval,mu0,lazy  19.01 0.46 180.28 21.14  21.53 0.23 263.14 31.75  917.83  20  7033 879.13   905.74  4   9462  1150.95
eqval,mu1,eager 18.92 0.34 129.43 17.84  18.89 0.35 225.86 23.34  1171.49 17  8162 1126.24  1161.05 6   14712 1475.33
eqval,mu1,lazy  25.99 0.56 180.8  24.76  25.71 0.24 325.35 31.58  1171.49 17  8162 1126.24  1160.64 6   14712 1475.32

Comments:
1. On eqval, mu0-eager is the best by average runtime on unsat. All in all, mu0-eager,
   mu0-lazy, and mu1-eager are quite close by this parameter.
2. On average, mu0 is better node-wise than mu1.


J)

Independent reduction before choosing a branching via the tau function.

Version 0.9.5

okserver:

1000 random instances, MOLS of order 7, 18 cells in the first LS are known (as in the
Latin Squares repository).

            time-unsat                time-sat                  nds-unsat                  nds-sat
            avg    min  max    sd     avg    min  max    sd     avg     min max   sd       avg     min max   sd
eq,eager    102.05 0.86 614.09 90.01  79.89  0.28 539.62 84.72  3964.23 31  23449 3506.68  3055.59 7   23197 3367.14
eq,lazy     127.5  1.19 731.56 113.3  100.89 0.38 733.72 110.7  3964.23 31  23449 3506.68  3056.09 7   23199 3367.11
val,eager   13.02  0.23 123.28 13.76  14.6   0.26 192.81 20.88  844.24  19  6146  772.34   806.59  6   6786  939.98
val,lazy    22.99  0.42 198.26 23.83  26.18  0.29 324.73 36.18  879.45  19  6146  804.93   859.39  7   6786  981.51
eqval,eager 17.59  0.32 165.55 20.66  20.8   0.24 350.58 34.4   917.83  20  7033  879.13   906.26  4   9465  1151.03
eaval,lazy  28.53  0.53 356.61 33.78  32.39  0.33 487.06 50.14  976.21  20  7135  970.04   967.71  7   9463  1218.98

Comments:
1. value-branching with eager reduction is the best time-wise and node-wise.
2. The average runtime on eager equality-value-branching slightly improved compared to 0.9.0.
3. For some reason, the number of nodes between eager and lazy variants of value-
   and equality-value-branchings are different. This should be investigated in more detail.


K)

Pruning in reduction.

Version 0.9.7

okserver:

1000 random instances, MOLS of order 7, 18 cells in the first LS are known (as in the
Latin Squares repository).

            time-unsat               time-sat                 nds-unsat                  nds-sat                    lvs-unsat                  lvs-sat
            avg   min  max    sd     avg   min  max    sd     avg     min max   sd       avg     min max   sd       avg     min max   sd       avg     min max   sd
eq,eager    84.55 0.72 496.56 75.12  66.65 0.24 488.65 73.23  3964.23 31  23449 3506.68  3055.59 7   23197 3367.14  1982.62 16  11725 1753.34  1525.5  2   11595 1683.56
eq,lazy     92.4  0.83 546.93 81.95  73.2  0.27 579.63 79.54  3964.23 31  23449 3506.68  3056.09 7   23199 3367.1   1982.62 16  11725 1753.34  1525.75 2   11596 1683.55
val,eager   10.61 0.18 108.75 11.59  12.17 0.21 160.16 17.64  844.24  19  6146  772.34   806.59  6   6786  939.98   630.71  15  4570  570.93   587.77  1   4586  675.41
val,lazy    15.37 0.26 158.41 16.88  18.47 0.21 255.98 27.35  879.45  19  6146  804.93   859.39  7   6786  981.51   657.2   15  4570  595.48   626.19  2   4586  706.71
eqval,eager 14.64 0.26 149.39 17.86  17.78 0.21 315.01 30.62  917.83  20  7033  879.13   906.26  4   9465  1151.03  651.34  15  4931  604.03   611.65  1   5402  737.02
eqval,lazy  20.06 0.35 282.27 25.45  23.99 0.24 390.9  39.61  976.21  20  7135  970.04   967.71  7   9463  1218.98  692.02  15  5163  664.39   651.86  1   5400  782.73

Comments:
1. The pruning improved the runtime by about 20-40 % in all cases. The number of nodes remains the same just like it
should be.
2. The average number of leaves on the val-branchers is the best one. eq-val is a bit worse, while eq is much worse.
