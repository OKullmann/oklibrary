Oliver Kullmann, 23.3.2023 (Swansea)

Priorities:

---

-1. One needs to read BicliqueLists
     - Same format as for general graphs, but with separator "|".
     - Since we are handling only graphs, not multigraphs (yet), automatically
       the covering-relation is assumed (multiple edges are ignored).
     - So that for ClauseLists, Graphs, BicliqueLists we have all
       conversions.

---

0. New program CNFstats.cpp

 - DONE Reading strict Dimacs.
 - DONE Reporting the dimacs-parameters.
 - DONE Then the clause-statistics.
 - DONE Then the variable-statistics.
 - DONE Then the basic conflict-graphs statistics V, E.
 - DONE Similar to the clause-statistics, a FreqStats-
   object for the degrees of the vertices of the
   conflict-graph is created and reported.
 - Output under "Variables" needs improvement:
  - the first three numbers need short explanations
  - the next six numbers need a better structuring
  - perhaps "trivial-pure" on one line
  - then "singular-nonsingular"
  - finally "1singular-non1singular".
 - Provide examples and explanations.

---

1. GSM.cpp:

TODOS:

-1. Output statistics
  - A log-file argument.

0. Fuzzing

 - Bicliques> ./Fuzzer "a20 40" "100*2,6;100*2,10" "" t
   running on server.
 - Bicliques> ./Fuzzer "a30 40" "100*2,6;100*2,10;10*2,3" "" t
   running on server.
 - Bicliques> ./Fuzzer "a40 e40 a40 40" "100*4,6" "" t
   running on server.
 - Bicliques> ./Fuzzer "a100 100" "100*2,4" u,m t
   running on server.
   Note "m" here (not "o", which yields an assert-error).

 - Bicliques> argument1="nopre" ./Fuzzer "a200 e100 a100 100" "100*4,4;50*2,4;100*3,2,1/3;100*4,10,1/4" "" t
   aborted after minisat-call run for 54h (on nt-component 0).

   Bicliques> argument1=nopre argument2=1000 ./Fuzzer "a200 e100 a100 100" "100*4,4;50*2,4;100*3,2,1/3;100*4,10,1/4" "" t
   running on server.

 - Needs to be automised.

  -Likely the name should be Fuzzer_GSM.


1. The option, that in case of no-improvement nothing is changed, is needed.

2. Better code-handling of replacement in sliced CNFs.

3. Add the usual comments to the output:
  - The parameter-values, version, etc.
  - With the usual formatting-options.

4. Handling dimacs and dqdimacs:
  - dqdimacs just needs a different to read, besides the possible
    outermost a-block, the dependencies, to fill it into the G-slided CNF.
  - dimacs could also be handled as a Gsliced CNF, just with all
    other-clauses being empty.
  - See QCNF2gCNF.cpp below.

---


2. BCC2SAT.cpp:

TODOS:

0. Write application-tests
    - And/or some fuzzer.

1. Running symmetry-breaking even if optimum already reached
    - By default we always run all rounds.
    - But for better speed there should be an option to stop once the
      upper bound has been reached.
    - UB isnt' used yet, and could be used here.

2. Special output for symmetry-breaking
  - Currently we run symmetry-breaking even if there is no output at all?
    Perhaps in this special case one only shows the symmetry-breaking results,
    nothing else (sb-rounds num_e-seeds + symmetry-breaking-section) ?
  - But perhaps this is better handled by a sb-results-only mode, that is,
    instead of "+- comments" we have:
     - all-comments
     - only-sb-comments
     - no-comments .

3. Option for greedy symmetry-breaking;
   see Bicliques2SAT.hpp below.

---

3. BCCbySAT.cpp:

TODOS:

0. Systematic treatment of file-output
  - Three possibilities: stats, log, solution.
  - There should always be the option "t", for automatic name;
    this uses the same timestamp; this timestamp is part of the
    comments-output in any case.
  - All streams by default are null.
  - Perhaps we use "cout" for standard output, and then use
    &std::cout.
  - For solution=null, no minisat-solution is used (need to check whether
    we can tell that in the minisat-call).
  - But still all minisat-calls run; if superfluous runs are to be avoided,
    then


1. Renewal of output
  - Additional output in the comments:
     - timestamp
     - statistics on the graph (at least V, E)
     - summary-statistics on solving (at least on conflicts and time;
       count, standard-statistics, sum).
  - Review the addition of line-ends for log and stats.
  - Explain the special case where no unsat-test
    is needed due to the results of symmetry-breaking.
  - There needs to be an (algo)-)option for just computing bcc/bcp, without
    computing a solution:
     - Then solution=null (as above).
     - And if lower-bound and upper-bound coincide, then also
       no solution is needed.
     - This replaces the BC-algo-option.
     - Perhaps NS ("no-solution"), with "-+ns" (default -ns).
     - We also have UB currently?? Seems out-dated.
     - Solution-output then is automatically null (error if not).


2. Currently the lower bound is just ignored (for downwards).
  - One needed perhaps a special return-type "conditionally exact" ?
  - A problem is that the solver-loop uses res.B, and not the bounds-
    object -- that needs update.
  - We need an option whether also for known exact-B one computes
    a solution or not.


3. Provide a mode which starts with B as given by symmetry-breaking
   (which is a sound lower bound), and then increases B as long as
   unsat was found.
    - This needs an extension of operator-() in BC2SAT.
    - As a further option it should be possible, for activated symmetry-
      breaking, to run internal UCP (without intermediate file-output).
    - See "Upwards-search" in Bicliques2SAT.hpp.


4. As an option, split into the connected components.
    - Or should this be an independent program?
      We have CNFBCC and GSM?

BUGS:

1.
Bicliques> ./GraphGen_debug grid 8 8 | ./BCCbySAT_debug 25,+0 -sb "" "" ""
BCCbySAT_debug: Bicliques2SAT.hpp:599: constexpr Bicliques2SAT::Bounds::Bounds(Bicliques2SAT::DI, bool, Bicliques2SAT::Bounds::id_t, Bicliques2SAT::Bounds::id_t, Bicliques2SAT::Bounds::id_t): Assertion `valid()' failed.
Aborted (core dumped)

---

4. CNFBCC.cpp:

1. Should be similar to BCCbySAT (above).
    - DONE logging should be handled in the same way.

BUGS:

-1. Inappropriate reaction yet when first run (for given B) is unsatisfiable.
  - The asserts at the end trigger.

0.
An instance where upper and lower bound coincide:

OLD:
Bicliques> cat temp/A_131_1623_1 | ./CNF2cg | ./BCCbySAT +0 nopre "" "" "" > OUT
CPU time              : 40.7075 s

With new (piped) form on server:
Bicliques> time cat temp/A_131_1623_1 | ./CNF2cg | ./BCCbySAT +0 nopre "" "" "" > OUT
real    2m42.009s
user    3m58.973s
sys     0m12.527s
> less OUT
|  Parse time:                  81.27 s                                       |
|  Simplification time:          7.95 s                                       |
restarts              : 1
conflicts             : 0              (0 /sec)
decisions             : 1              (0.00 % random) (0 /sec)
propagations          : 1220134        (13674 /sec)
conflict literals     : 0              (-nan % deleted)
Memory used           : 14899.69 MB
CPU time              : 89.2333 s
Why such a long total time??
Bicliques> time cat temp/A_131_1623_1 | ./CNF2cg | ./BCCbySAT +0 nopre "" "" "" > OUT_NEW
real    1m14.948s
user    1m47.713s
sys     0m7.851s
|  Parse time:                  36.70 s                                       |
|  Simplification time:          7.91 s                                       |
CPU time              : 44.6112 s


OLD:
Bicliques> time cat temp/A_131_1623_1 | ./CNFBCC nopre "" "" "" "" ""
real    1m54.284s
user    1m41.837s
sys     0m11.462s

With new form on server:
Bicliques> time cat temp/A_131_1623_1 | ./CNFBCC nopre "" "" "" "" "" > OUT2
real    2m47.329s
user    4m4.146s
sys     0m12.254s
Why so much slower now?
Apparently the hand-shaking takes more time?
Bicliques> time cat temp/A_131_1623_1 | ./CNFBCC nopre "" "" "" "" "" > OUT2_NEW
real    1m14.649s
user    1m47.538s
sys     0m7.527s



Storing on file on server:
Bicliques> time cat temp/A_131_1623_1 | ./CNF2cg | ./BCC2SAT 0 nopre "" "" "" > OUT.cnf
real    1m15.843s
user    1m12.755s
sys     0m3.090s
Bicliques> ls -l OUT.cnf
6123851055  OUT.cnf
Bicliques> time minisat -no-pre OUT.cnf
|  Parse time:                  31.96 s                                       |
|  Simplification time:          7.99 s                                       |
restarts              : 1
conflicts             : 0              (0 /sec)
decisions             : 1              (0.00 % random) (0 /sec)
propagations          : 1220134        (30537 /sec)
conflict literals     : 0              (-nan % deleted)
Memory used           : 14899.69 MB
CPU time              : 39.9554 s
real    0m45.164s
user    0m39.958s
sys     0m5.204s
Without storage:
Bicliques> time cat temp/A_131_1623_1 | ./CNF2cg | ./BCC2SAT 0 nopre "" "" "" | minisat -no-pre /dev/stdin
|  Parse time:                  42.71 s                                       |
|  Simplification time:          7.93 s                                       |
CPU time              : 50.6394 s
real    1m25.711s
user    2m4.683s
sys     0m8.415s

Far faster than BCCbySAT and CNFBCC.
One needs to see whether direct FILE*-output (without first calling
the ostream-output and storing this on string) is much faster.


1.
Bicliques> echo -e "p cnf 2 4\n1 2 0\n1 -2 0\n-1 -2 0\n-1 2 0\n" | ./CNFBCC_debug partition2 "" "" t
CNFBCC_debug: CNFBCC.cpp:126: int main(int, const char* const*): Assertion `res.rt != ResultType::init_unsat_sb and res.rt != ResultType::init_unsat and res.rt != ResultType::unknown' failed.

The start-value is not sufficient here, since one doesn't start with a
precise realisation.

2.
Bicliques> BRG "20*15,3" | ./CNFBCC nopre "" "" "" "" +1
p cnf 0 20
...


---

5. GCGeq.cpp:

TODOS:

1. Output showing the differences
2. Help should show the meaning of the return-codes.

---

6. Bicliques2SAT.hpp:

TODOS:

-1. Finish class Bounds

  1. di==DI::downwards: until the first unsatisfiable

   - only u given:
     c = u; l = 0;
     for ub==UB::trust: c = u-1 ?
       what if here u==l ?
     perhaps bool found_unsatifiable, found_satisfiable ?

  2. di==DI::upwards: until the first satisfiable

   - nothing given:
     l, u = trivial, c = l
     better with G taken into account

   - l given:
     u = trivial, c = l
     better with G taken into account

  The lower bound needs to be updated via sb.
  The upper bound doesn't need to be updated (but possible is updated).


0. Upwards-search

1. UCP for BC2SAT

(a) The class gets bloated, but for a start it seems easiest to develop
    the functionality in this (richer) context.

(b) Given and initial edge-placement via sb of type vei_t and an initial
    consistent bcc-frame F (either empty or obtained by complete previous
    processing), place the edges of sb in F, and perform complete UCP for F.

(c) A bcc-frame F contains for each 0 <= i < B:
  - the assigned vertices L, R;
    perhaps as sorted vectors; both are empty or both are non-empty;
  - the (other) possible vertices PL, PR;
    as long as L,R are empty, also PL, PR are empty, and then with the first
    edge PL, PR are assigned the other neighbours;
    with further edges only the common neighbours remain;
    this data only shrinks (after the initial setting), so perhaps also a
    sorted vector is best;
  - the edges watching this bc, as pairs (i,e), with 0 <= i < E and e in {0,1},
    for the direction (forward/backward).

(d) For each edge-index 0 <= i < E:
     - indication whether assigned to which biclique (with which polarity)
     - if unassigned, then two watched bicliques (with polarity; which
       can cover the edge)
    The two watched bicliques in "ladder- order" (updating advances
    in this order).

2. Implement partition1:
  - This linear form is available under LatinSquares.
  - At this time then the structure of BC2SAT needs to be improved.

3. More efficient symmetry-breaking
   (not taking the symmetries of the graph into account, only
   "all completely open bicliques are alike").

  - Likely this should go into a dedicated file.
  - A more intelligent algorithm is needed.
  - And also a greedy version, choosing from the available edges one with
    minimum sum (or product) of degrees of end-points.

    More precisely, one considers the resulting sizes of the possible
    sides, and minimises their sum resp. product (oder tau?).

    This can be easily achieved by just sorting, after the initial random
    permutation, the edges according to this criterion (just using std::sort)
    -- only this additional step is needed, then by always choosing the first
    remaining edge we get greediness (since the population of other bicliques
    does not matter here).

    Actually the best heuristics should be to sort the edges according to the
    number of compatible edges (the fewer the better).
    A refined version updates this according to the edges already placed.
  - DONE
    For cases which take a long time, a log-output with the current best
    and its index (for the seed) is needed.
    From that index one should be able to perform a single run.
  - One should also return the result in general (for quick reproduction):
    just the complete seed plus what has been achieved (so that with a single
    round one can recompute the sb-assignment, and one can stop as soon as
    in that single run one filled all available bicliques).

  - Extended symmetry-breaking: if a maximal sb-assignment left k >= 2
    bicliques unoccupied (which we assume are the k last ones), use the
    following "potential placements":
     for the first k-1 unplaced edges, forbid the final k-1, k-2, ..., 1
     bicliques (this means "conditionally occupying" bicliques
     B-k+1, B-k+2, ..., B-1).
     And also conditionally choose the canonical order (smaller vertex first),
     that means for the conditionally occupied biclique a further binary
     clause forbidding the wrong order.
  - This creates negative unit-clauses (k(k-1)/2).
  - In this way all bicliques are at least conditionally occupied, and all
    internal symmetries are broken.
  - No further basic statistics are needed.
  - The same greedy mechanism (presorting the edges) from above works here
    (no further action needed).
  - This "extension" can always be applied, for example also to the empty
    sb-assignment.
    So perhaps better speaking of "trivial" or "uninformed" symmetry-breaking
    fo this scheme.

  - If we have a maximal sb-assignment, then every non-placed edge has at least
    one occupied biclique to go, so if there is at least one open biclique
    (which we denoted here by B > sb), then no further UCP is possible.
  - So basic UCP (combined with basic sb) just cleans up the occupied
    bicliques (keeping only the relevant vertices and related 2-clauses)
    and for every edge cleans up the list of available bicliques.
    If B > bcp, then no further unit-clauses can be derived.
    To enable recovering of the solution, all relevant unit-clauses are
    placed in the output.

    It seems best to create for all clause-creating functions another version
    which takes an sb-assignment as input.
  - One could then also always run "special UCP, for B = sb, seeing whether
    a decision can be reached here.

  - A more intelligent version runs the full process with extension and UCP,
    and judges the outcome (for example minimising the sum of the volumes of
    the potential bicliques).

  - The options are (five independent groups):

     - no basic-sb
     - basic-sb (just adding the 3k unit-clauses)
     - basic-sb-with-clean-up (this should be the default)

     - no trivial-sb
     - trivial-sb (the default)

     - no-test-B=sb
     - test-B=sb (for the best order found)
     - test-B=sb-every-order

     - place unit-clauses last (default)
     - place unit-clauses first

     - random order
     - sorting by number of compatible edges (static)
     - sorting by number of compatible edges (dynamic)

  -


4. GCC compiler error CERR
  - When updating to GCC version 12 or later, activate the places with CERR
    (currently disabled due to compiler error)

---

7. DimacsTools.hpp:

TODOS:

-1. Variation of extract_gpart_strictqcnf, which extracts the
    global slice and the remainder into a pair of clause-lists
     - Every initial clause is read into a pair of ClauseSet,
       with the global literals and the remaining literals.
     - Using a pair or a struct? In any case, perhaps with the
       above order.
     - Do we need lexicographical order on these pairs?
       Perhaps, and then it seems the non-global part is more
       important (since fixed), and thus should indeed come first.
     - Perhaps a struct SClause (split-clause), with components
       O, G : Clause.
     - Typedef SClauseList (vector).
     - For the parameters we have the other variables, the global
       variables, and the clauses.
     - Perhaps a struct with components o, g, c, named s_dimacs_pars.
     - The pair then is SDimacsClauseList.
     - The meaning of o, g is simply the maximal index used by the
       respective variables; if first we have all o-variables, then all
       g-variables, one can also infer their numbers.
     - Alternatively one could use to DimacsClauseLists (with the same
       number of clauses). Perhaps this is more appropriate to express the
       nature of "slices" ?
       Then no new data structures are needed: equivality of the o-slice
       by direct comparison, etc.; looks better.
       So an SDimacsClauseList is then a pair of DimacsClauseList, with the
       second component the global slice.
       One could also use a tuple, or a vector?
     - The main operation (for now) is the gcg-equivalence of two
       SDimacsClauseList : the global slices have the same conflict-graph,
       the remaining-slices are equal.
     - This is simply implemented by first checking whether the o+c-parameters
       are equal, in which case then first the equality of the other-slice
       is checked, in which case then a nested loop over all pairs of g-clauses
       checks whether the corresponding pairs either have at least one conflict
       or have no conflict.
     - Similar to the computatio of ConflictGraphs::conflictgraph_bydef
       (using global complements of the global slices and checking for
       non-empty intersections).
     - The corresponding application, GCGeq, reads the two QCNFs and determines
       their equivalence.
     - We require for gcg-equivalence that the c-parameters are equal, and thus
       we can concatenate both inputs to standard input.
     - In case of inequality a precise witness needs to be output; so the
       equivalence-check needs to output an object which contains the
       witnesses.

0. Generalise extract_apart_strict2qcnf to handle arbitrary qcnf
   (extracting "global variables").

1. In the same way, generalise extract_apart_strict2qcnf to dqcnf.

3. DONE (some reports are needed)
   Directing a stream to stdin of minisat
   - DONE This is important for very large files (especially when used in
     parallel).
   - DONE The tool here to use is
     ( https://man7.org/linux/man-pages/man3/popen.3.html )
     #include <stdio.h>
     FILE *popen(const char *command, const char *type);
     int pclose(FILE *stream);
   - DONE The pclose-function returns the exit-status.
   - DONE Better to use std::FILE from cstdio
     https://en.cppreference.com/w/cpp/io/c/FILE
   - DONE (using template-parameters)
     Within C, C++, Posix, there doesn't seem to be a way, given
     a FILE*, to convert this into an ostream.
     Thus the file-output-function need to be duplicated: additionally
     to the C++-function also C-functions, outputting to FILE*.

4. skip_strict_eline : don't store the characters discarded.
   - Similarly in read_string_gline.

---

8. We need, besides Disassemble.cpp, als Reassemble.cpp.

---

9. QCNF2gCNF.cpp:

TODOS:

1. Generalise to DQCNF
    - The set of global variables now is the intersection of the
      dependencies of all existential variables.
    - See GSM above.
    - Perhaps this should be a new program, DQCNF2gCNF.cpp ?

---

10. Generators.hpp

1. Providing a creation-mode, which creates only half of the edges
    - Currently for undirected graphs, every edge is printed twice.

2. Prove that bcp(crown(n)) = n.

3. What is bcp(grid(n,m)) ?

4. We should have the cnf-generation-functions for all provided
   graph-types.

---

11. GraphGen.cpp

1. Provide better documentation on output

2. Can we obtain the basic forms of random graphs from BRG?
   Or should they be provided here?

---

In general:

 - good support for statistics
 - parallelisation.
