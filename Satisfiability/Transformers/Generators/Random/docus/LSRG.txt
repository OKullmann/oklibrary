Oleg Zaikin, 24.12.2020 (Swansea)
Copyright 2020 Oliver Kullmann
This file is part of the OKlibrary. OKlibrary is free software; you can redistribute
it and/or modify it under the terms of the GNU General Public License as published by
the Free Software Foundation and included in this library; either version 3 of the
License, or any later version.

Documentation for LSRG.cpp

Example usage for creating two latin squares of order 10, with a
seed-sequence "0" (using the debug-version):

Random> ./LSRG_debug 10 2 0
 ...
c ** Parameters **
c command-line                          "./LSRG_debug" "10" "2" "0"
c N                                     10
c m                                     2
c output                                "-cout"
c num_e-seeds                           1
c  e-seeds                              0
c RESULT: 1000 iterations
c 0 of them additional iterations
c 122 of them produced proper Latin squares
3 9 8 4 1 2 7 6 5 0
7 2 5 0 4 3 1 9 8 6
2 4 6 5 0 9 8 7 3 1
5 3 9 7 8 6 4 1 0 2
8 5 1 6 3 0 2 4 7 9
9 8 3 2 7 1 6 0 4 5
4 6 2 9 5 8 0 3 1 7
0 1 4 8 6 7 9 5 2 3
1 7 0 3 9 4 5 2 6 8
6 0 7 1 2 5 3 8 9 4

c RESULT: 1037 iterations
c 37 of them additional iterations
c 109 of them produced proper Latin squares
1 4 3 9 5 7 0 6 2 8
7 9 6 5 4 1 2 0 8 3
4 6 1 7 8 3 9 2 0 5
3 7 5 0 9 2 6 8 4 1
6 0 2 3 7 5 8 1 9 4
9 3 7 8 0 4 1 5 6 2
8 1 4 2 6 9 7 3 5 0
5 2 0 6 1 8 4 9 3 7
2 8 9 1 3 0 5 4 7 6
0 5 8 4 2 6 3 7 1 9



Details:

The program implements the Jacobson-Matthews algorithm for generating random Latin
squares. This algorithm was published in:
Mark T. Jacobson, Peter Matthews. Generating uniformly distributed random latin
squares // Journal of Combinatorial Designs. 1996.

The main program's inputs are N (order) and M (the required number of random Latin
squares). M times a random Latin square of order N is generated as follows:

At the beginning a Latin square of order N is constructed. It can be done via
various approaches, by now it is done by constructing a multiplication table for a
cyclic group.

Order N is considered, and {0,1,...,N-1} are the possible values of a Latin
square's cells. The row and column-sum of a Latin square is thus
  S = 1 + ... + N-1 = N * (N-1) / 2.

XXX in the following the use of "l_i" seems misleading (or wrong)
The condition on cells is relaxed, allowing an "improper" Latin
square with a single cell with symbolic value "l_i + l_j - l_k", where i, j, k are
distinct indices from {1,...,N}. The symbolic sum of cells' values in each line must be
equal S (as for a proper Latin square), so if a row or a column has the cell
l_i + l_j - l_k, then it also has two cells with values l_k and no cell with value l_i
or l_j.

XXX Question: does one actually need the "symbolic sum"?? It seems better to just
explicitly state what the conditions for an "improper Latin square" are.
It seems a "symbolic value" is just a triple (a,b,c), with distinct *values*
(from {0,...N-1}, as usual). Thus the definition of an "improper ls" is
1) Possible entries are from V:={0,...,N-1} union {(a,b,c)}, where
     (a,b,c) in V^3, a < b, c notin {a,b}.
2) The special entry occurs at most once.
3) If a row or column does not contain a special entry, then the (ordinary) values
   are exactly those from V (all occurring, none twice).
4) If a row or column contains (a,b,c), then there are two entries c,
   and the N-3 values of the remaing cells are exactly those from V - {a,b,c}.
   (Thus when interpreting "(a,b,c)" as contributing "a+b-c" to a sum, then every
    row- and every column-sum equals S.)

A move consists of identifying a suitable 2 * 2 subtable and incrementing or
decrementing each cell in a way that leaves at most one cell of the form
l_i + l_j - l_k and all sums equal to S. As a result, a proper Latin
square can become improper and vice versa.

The program performs N^3 such moves, then if an improper Latin square is obtained,
additional moves are done until a proper Latin square is appeared.


XXX Documentation of usage, and documentation of special values
XXX this is actually the real documentation -- the above is additional information
