#!/usr/bin/env bash
# Oliver Kullmann, 2.4.2020 (Swansea)
# Copyright 2020 Oliver Kullmann
# This file is part of the OKlibrary. OKlibrary is free software; you can redistribute
# it and/or modify it under the terms of the GNU General Public License as published by
# the Free Software Foundation and included in this library; either version 3 of the
# License, or any later version. */

# USAGE:

# A1Reduction
# reads a (D)QCNF-file from standard input and creates a directory with files:
# - result (one of SAT, LEAN, MIXED, except of solver-abortion, where then
#    it is one of ALEAN, AMIXED, if already some solver-results were obtained,
#    otherwise the file doesn't exist)
# - result_clauses (the clause-indices of the autarkies found, one per line)
# - result_number (the total number of satisfied clauses).

# Output to standard-ouput: content of result and result_number, plus
# the number of lines in result_clauses (i.e., number of autarkies).

# Main variables for customisation, and their default-values:
# - input = /dev/stdin
# - call_translator = AutarkiesL1
# - satwrapper = SATWrap_minisat
# - directory = ${program}_${filename}_${satwrappername}_${timestamp}

# TODOS:
# 1. Report the minisat-stats, in new file result_minisat.

# #########################

set -o errexit
set -o nounset

program="A1Reduction"
version="0.3.4"

: ${input:="/dev/stdin"}
filename="$(basename ${input})"

: ${call_translator:="AutarkiesL1"}
: ${call_applypass:="ApplyPass-O3-DNDEBUG"}
: ${call_ucp:="UnitClausePropagation-O3-DNDEBUG"}

: ${satwrapper:="SATWrap_minisat"}
satwrappername="$(basename ${satwrapper})"

timestamp="$(date +%s%N)"

: ${directory:="${program}_${filename}_${satwrappername}_${timestamp}"}
mkdir ${directory}

file="${directory}/translated.dimacs"
${call_translator} ${input} ${file} -nil vs 0

# Concluded with "0" (a Dimacs-clause):
clauseselectors="${directory}/cs_selectors"
tail -1 ${file} > ${clauseselectors}
numclauses=$(cat ${clauseselectors} | awk '{print $(NF-1)}')

# A text-file, per line the clause-indices as deleted by the
# corresponding autarky:
resultclauses="${directory}/result_clauses"
touch ${resultclauses}
resultnumber="${directory}/result_number"


solverdirectory="${directory}/SAT"
inputfile="${file}" outputdirectory="${solverdirectory}" outputfile="/dev/null" ${satwrapper}
if [ -s ${solverdirectory}/err ]; then
  echo "[${program}]: ERROR with solver" >> /dev/stderr
  exit 1
fi

# A Dimacs-assignment:
positiveassignments="${directory}/positives"
# Just the clause-indices:
clauseassignments="${directory}/clauses"

newtranslation="${directory}/new_translation"
finalnew="${directory}/final_new"

result="${directory}/result"


cleanup() {
  rm ${clauseselectors}
  rm -f ${positiveassignments} ${clauseassignments} ${newtranslation} ${finalnew}
  status=$(cat ${solverdirectory}/status)
  rm -r ${solverdirectory}
  cat ${resultclauses} | wc -w > ${resultnumber}
  resultnum=$(cat ${resultnumber})
  if (( status == 0 )); then
    if (( resultnum == 0 )); then
      echo " ALEAN" > ${result}
    elif (( resultnum > 0 )); then
      echo " AMIXED" > ${result}
    else
      echo "ASSERTION ERROR ${program}: UNKNOWN-case!" >> /dev/stderr
      exit 1
    fi
  elif (( status == 10 )); then
    if (( resultnum == numclauses )); then
      echo "ASSERTION ERROR ${program}: SAT-case!" >> /dev/stderr
      exit 1
    fi
  elif (( status == 20 )); then
    if (( resultnum == numclauses )); then
      echo "SAT" > ${result}
    elif (( resultnum == 0 )); then
      echo "LEAN" > ${result}
    else
      echo "MIXED" > ${result}
    fi
  else
    echo "[${program}]: ERROR with solver in directory:" >> /dev/stderr
    realpath ${directory} >> /dev/stderr
    echo "return-code=${status}" >> /dev/stderr
    exit 1
  fi
  echo "$(cat ${result}) ${resultnum} $(cat ${resultclauses} | wc -l)"
}


trap handler SIGINT

handler() {
  cleanup
  exit 0
}


while [ -s ${solverdirectory}/pass ]; do

  echo -n "v " > ${positiveassignments}
  cat ${solverdirectory}/pass | awk '{for (i=1; i<=NF-1; ++i) if ($i >= 1) printf "%d ", $i}' >> ${positiveassignments}
  cat ${positiveassignments} | awk '{for (i=2; i<=NF; ++i) if ($i <='${numclauses}') printf "%d ", $i}' > ${clauseassignments}
  cat ${clauseassignments} >> ${resultclauses}
  echo >> ${resultclauses}

  echo " 0" >> ${positiveassignments}
  cat ${file} | ${call_applypass} ${positiveassignments} ${newtranslation}
  rm ${file}
  cat ${newtranslation} | ${call_ucp} | awk '{if ($1 == "p") print "p cnf " $3 " " 1+$4; else print $0}' > ${finalnew}

  declare -A current_clauses
  for i in $(cat ${clauseselectors}); do
    current_clauses[$i]=0
  done
  unset current_clauses[0]
  for i in $(cat ${clauseassignments}); do
    unset current_clauses[$i]
  done
  echo -n "${!current_clauses[*]}" > ${clauseselectors}
  echo " 0" >> ${clauseselectors}
  cat ${clauseselectors} >> ${finalnew}

  rm -r ${solverdirectory}
  inputfile="${finalnew}" outputdirectory="${solverdirectory}" outputfile="/dev/null" ${satwrapper}
  if [ -s ${solverdirectory}/err ]; then
    echo "[${program}]: ERROR with solver in directory:" >> /dev/stderr
    realpath ${directory} >> /dev/stderr
    echo "Solver output on stderr:\n" >> /dev/stderr
    cat ${solverdirectory}/err >> /dev/stderr
    exit 1
  fi
  file="${finalnew}"
done


cleanup
exit 0
